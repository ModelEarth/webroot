<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <title>Sector Analysis - Impacts of supply chain</title>
  <link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link href="https://unpkg.com/tabulator-tables@5.2.7/dist/css/tabulator.min.css" rel="stylesheet">
  <script type="text/javascript" src="https://unpkg.com/tabulator-tables@5.2.7/dist/js/tabulator.min.js"></script>

  <!-- The id here prevents the older file from loading -->
  <script type="text/javascript" srcX="../../localsite/js/d3.v5.min.js" id="/localsite/js/d3.v5.min.js"></script>
  <script type="text/javascript" srcX="../../localsite/js/jquery.min.js" id="/localsite/js/jquery.min.js"></script>

  <!-- instead we use newer files -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>

  <script type="text/javascript" src="../../localsite/js/localsite.js?showheader=true&showsearch=true"></script>
  <script src="js/useeio.js"></script>

  <script type="text/javascript" src="../../team/js/common.js" id="/team/js/common.js"></script>
  <script type="text/javascript" src="../../team/js/widget.js" id="/team/js/widget.js"></script>

  <style>
    .fullscreen-toggle-container {
      display: inline-block;
    }
    
    .fullscreen-toggle-btn {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .fullscreen-toggle-btn:hover {
      background: rgba(255, 255, 255, 1);
      border-color: #007bff;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }
    
    .fullscreen-icon {
      width: 16px;
      height: 16px;
      color: #666;
    }
    
    .fullscreen-toggle-btn:hover .fullscreen-icon {
      color: #007bff;
    }
    
    /* Make charts responsive and auto-scale to their containers */
    #chart2, #sankey {
      width: 100% !important;
      height: 100% !important;
    }
    
    #chart2 svg, #sankey svg {
      width: 100% !important;
      height: 100% !important;
      max-width: 100%;
      max-height: 100%;
    }
    
    /* Ensure charts scale in hero mode */
    #widgetHero #chart2, #widgetHero #sankey {
      width: calc(100vw - 42px) !important; /* Account for 60px left - 18px right = 42px difference */
      height: 100vh !important;
      padding: 20px;
      box-sizing: border-box;
    }
    
    #widgetHero #chart2 svg, #widgetHero #sankey svg {
      width: calc(100vw - 82px) !important; /* 42px padding difference + 40px internal padding */
      height: calc(100vh - 40px) !important;
    }
    
    #table {
      margin: 20px 0;
      height: auto !important; /* Override fixed height */
    }
    .tabulator-cell {
      white-space: normal;
      overflow: visible;
      padding: 8px;
    }
    .tabulator .tabulator-header .tabulator-col {
      background-color: #f4f4f4;
    }
    /* Add these rules to remove empty space */
    .tabulator-tableholder {
      height: auto !important;
      min-height: 0 !important;
    }
    .tabulator {
      height: auto !important;
    }
    .controlDD {
      width: 90px;
      padding: 4px 8px;
      font-size: 12px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: white; /* covers down arrow */
    }
    .dark .controlDD {
      background: #333;
    }
    
    /* Control bar layout */
    .control-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      gap: 8px;
    }
    
    .control-selects {
      display: flex;
      gap: 8px;
    }
    
    /* Responsive layout for narrow screens */
    @media (max-width: 400px) {
      .control-bar {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .control-selects {
        align-self: stretch;
        justify-content: flex-end;
      }
    }
  </style>
</head>

<body>
  
  <div style="padding-left:20px;padding-right:18px;">
    <a id="footprintLink" href="../state/" >State Impact Reports</a>
    <h2>Sector Supply Impacts</h2>

    <!-- D3 Separated chord chart -->
    <div style="position: relative;">
      <div>

          <style>
            /* Row layout: chart2 (45%), sankey (45%), controls (5%) */
            .charts-row {
              display: flex;
              gap: 0; /* no empty space between columns */
              align-items: stretch;
              width: 100%;
            }
            /* Use fixed flex-basis so total is exactly 100%: 45% + 45% + 5% = 95% (outer padding consumes rest), but no gaps between */
            .charts-row > .chart-left {
              flex: 0 0 45%;
              min-width: 160px;
              height: 480px;
              padding: 0;
              margin: 0;
            }
            .charts-row > .chart-center {
              flex: 0 0 45%;
              min-width: 160px;
              height: 480px;
              padding: 0;
              margin: 0;
            }
            .charts-row > .chart-right-controls {
              flex: 0 0 8%;
              min-width: 110px; /* wider so labels don't truncate */
              display: flex;
              flex-direction: column;
              gap: 6px;
              align-items: flex-end; /* push controls to the right */
              justify-content: flex-start;
              height: 480px;
              padding: 0 6px 0 0;
              margin: 0;
            }
            .chart-right-controls .controlDD {
              width: 120px;
              max-width: 140px;
              box-sizing: border-box;
              margin: 0;
              padding: 6px 8px;
            }
            @media (max-width: 900px) {
              .charts-row {
                    flex-direction: column;
                  }
                  .charts-row > .chart-left,
                  .charts-row > .chart-center,
                  .charts-row > .chart-right-controls {
                    width: 100%;
                    min-width: 0;
                    height: 360px;
                  }
            }
          </style>


      <!-- Top control bar above charts -->
      <div class="control-bar">
        <div id="relocatedStateMenu"></div>
        <div class="control-selects">
          <select id="theme-mode" class="controlDD">
            <option value="light" selected>Light Mode</option>
            <option value="dark">Dark Mode</option>
          </select>
          <select id="scaling-method" class="controlDD">
            <option value="raw" selected>No Scaling</option>
            <option value="square-root">Square Root</option>
            <option value="proportional">Proportional</option>
            <option value="logarithmic">Logarithmic</option>
          </select>
          <select id="edge-style" class="controlDD">
            <option value="none">No Edge</option>
            <option value="light" selected>Light Edge</option>
            <option value="dark">Dark Edge</option>
          </select>
        </div>
      </div>

      <div id="widgetHero"></div>
      
          <div style="display:flex; gap:20px; width:100%">
            <!-- Left: D3 Separated chord chart -->
            <div id="chart2Parent" style="flex:0 0 25%; min-width:300px; height:480px; position:relative;">
              <div id="chart2Wrapper" myparent="chart2Parent" class="widgetPanel" style="width:100%; height:100%; position: relative;">
                <div id="chart2" style="width:100%; height:100%;"></div>
                <!-- Expand Icon for Chart2 -->
                <div class="fullscreen-toggle-container" style="position: absolute; top: 8px; right: 8px; z-index: 10;">
                  <button class="fullscreen-toggle-btn" mywidgetpanel="chart2Wrapper" onclick="myHero()" title="Expand Chart">
                    <svg class="fullscreen-icon expand-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                    </svg>
                    <svg class="fullscreen-icon collapse-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display: none;">
                      <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/>
                    </svg>
                  </button>
                </div>
              </div>
            </div>
            <!-- Right: Sankey chart will sit alongside the chord chart -->
            <div id="sankeyParent" style="flex:1; min-width:300px; height:480px; position:relative;">
              <div id="sankeyWrapper" myparent="sankeyParent" class="widgetPanel" style="width:100%; height:100%; position: relative;">
                <div id="sankey" style="width:100%; height:100%;"></div>
                <!-- Expand Icon for Sankey -->
                <div class="fullscreen-toggle-container" style="position: absolute; top: 8px; right: 8px; z-index: 10;">
                  <button class="fullscreen-toggle-btn" mywidgetpanel="sankeyWrapper" onclick="console.log('Sankey clicked'); myHero()" title="Expand Sankey">
                    <svg class="fullscreen-icon expand-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                    </svg>
                    <svg class="fullscreen-icon collapse-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display: none;">
                      <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/>
                    </svg>
                  </button>
                </div>
              </div>
            </div>
          </div>
      </div>
  </div>

  <div style="padding-left:60px;padding-right:18px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <p id="info" style="margin: 0;">Loading ...</p>
        <select id="number-format-select" style="margin-left: 10px;">
            <option value="simple" selected>simple</option>
            <option value="full">full</option>
            <option value="scientific">scientific</option>
        </select>
    </div>
    <div id="table"></div>
    <div style="display:block; margin: 10px 0 20px 0;">
      <a href="#" id="showAllLink">Show all rows</a>
    </div>
  </div>
  
  <script src="js/config.js"></script>
  <!-- include d3-sankey -->
  <script src="https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
  <!-- Repository sankey implementation removed to avoid runtime mismatch; using inline fallback -->
  <script type="module">
    // Importing chord diagram initialization function
    // chordInit.js loads script.js in same folder.
    import { initializeChordDiagram } from './chord/stretched/chordInit.js';
    // Add at the top level of the script, outside any function
    let isShowingAllRows = false;
    let table;
    let currentData = null; // Add this to track current data state
    let allResults = null; // Add this to store full dataset

    // creating function chartData to store the data for the chord diagram
    let chartData = {
        nodes: [],
        links: []
    };

    document.addEventListener('hashChangeEvent', hashChangedUseeio, false);
    function hashChangedUseeio() {
      console.log("URL hash changed");
      model = getModel();
      isShowingAllRows = false;
      currentData = null;
      
      // Reset format to simple when state changes
      const formatSelect = document.getElementById('number-format-select');
      formatSelect.value = 'simple';
      
      // Reset show all link visibility and state before loading new state
      const showAllLink = document.getElementById('showAllLink');
      showAllLink.style.display = 'inline-block';
      isShowingAllRows = false;
      
      main();
    }
    async function main() {
      let hash = getUrlHash();
      const info = document.getElementById("info");
      const demandId = await model.findDemand({
        system: "Complete",
        type: "Consumption",
      });
      if (!demandId) {
        info.textContent = "Failed to load demand";
        return;
      }

      const sectors = await model.sectors();
      // Use first sector for consistent results instead of random
      const sector = sectors[0];
      console.log(`Base analysis sector: ${sector.code} - ${sector.name}`);
      info.textContent = `Analyzing sector '${sector.name}' based on ${demandId}`;

      const analysis = await useeio.SectorAnalysis.of(model, sector, demandId);
      const indicators = await model.indicators();

      const total = await analysis.getSupplyChainImpacts(indicators);
      const byIndicator = {};
      for (const indicator of indicators) {
        byIndicator[indicator.code] = await analysis.getSupplyChainImpacts(indicator);
      }
      const results = [];
      console.log(`Processing ${sectors.length} sectors for supply chain impacts`);
      for (const sectorItem of sectors) {
          // Store raw values for proper sorting
          const rawTotal = Math.abs(total[sectorItem.index]);
          const result = {
              sector: sectorItem.name, // Just the name without NAICS code
              total: rawTotal,
              totalRaw: rawTotal, // Add raw value for sorting
              sortValue: rawTotal, // Explicit sort value
              // Additional metadata for popups
              metadata: {
                  NAICS: sectorItem.code,
                  fullName: `${sectorItem.code} - ${sectorItem.name}`,
                  index: sectorItem.index,
                  location: sectorItem.location || 'N/A'
              }
          };
          indicators.forEach(i => {
              const value = byIndicator[i.code][sectorItem.index];
              result[i.code] = value;
          });
          results.push(result);
      }

      // Sort results by total impact
      results.sort((a, b) => b.sortValue - a.sortValue);

      // Store all results for later use
      allResults = results.sort((a, b) => b.sortValue - a.sortValue);
      // Take top 10 initially
      const sortedResults = allResults.slice(0, 10);

      // Replace the existing formatNumber function with:
      function formatNumber(value, formatType) {
          // Handle true zero or undefined values
          if (value === 0 || !value) {
              return '0.0000';
          }
          
          switch(formatType) {
              case 'simple': {
                  // Update threshold to 1e-33 for decillionth
                  if (Math.abs(value) < 1e-33) {
                      return value.toExponential(4);
                  }
                  
                  const expSimple = value.toExponential();
                  const [mantissaSimple, exponentSimple] = expSimple.split('e');
                  const power = parseInt(exponentSimple);
                  
                  // Function to convert scientific notation to word form
                  function getNumberWord(power) {
                      const words = {
                          0: '',
                          3: 'thousand',
                          6: 'million',
                          9: 'billion',
                          12: 'trillion',
                          15: 'quadrillion',
                          18: 'quintillion',
                          21: 'sextillion',
                          24: 'septillion',
                          27: 'octillion',
                          30: 'nonillion',
                          33: 'decillion',
                          '-1': 'tenth',
                          '-2': 'hundredth',
                          '-3': 'thousandth',
                          '-6': 'millionth',
                          '-9': 'billionth',
                          '-12': 'trillionth',
                          '-15': 'quadrillionth',
                          '-18': 'quintillionth',
                          '-21': 'sextillionth',
                          '-24': 'septillionth',
                          '-27': 'octillionth',
                          '-30': 'nonillionth',
                          '-33': 'decillionth'
                      };

                      // Handle numbers with no exponent (e+0) or small positive exponents
                      if (power >= 0 && power < 3) {
                          const adjustedValue = parseFloat(mantissaSimple) * Math.pow(10, power);
                          return adjustedValue.toFixed(4);
                      }

                      // For extremely small numbers beyond decillionth
                      if (power < -33) {
                          return value.toExponential(4);
                      }

                      // For small numbers, use exact power if available
                      if (power < 0 && power > -3) {
                          const word = words[power];
                          if (word) {
                              const adjustedMantissa = parseFloat(mantissaSimple) * Math.pow(10, -power);
                              return `${adjustedMantissa.toFixed(4)} ${word}`;
                          }
                      }

                      // For other numbers, use the ceiling of negative power/3 or floor of positive power/3
                      const absExponent = Math.abs(power);
                      let nearestPower;
                      if (power < 0) {
                          // For negative powers, we need to round up to the next power of 3
                          nearestPower = Math.ceil(absExponent / 3) * 3;
                      } else {
                          // For positive powers, keep using floor
                          nearestPower = Math.floor(absExponent / 3) * 3;
                      }
                      
                      const word = words[power > 0 ? nearestPower : -nearestPower];
                      
                      if (!word) return value.toExponential(4);
                      
                      // Adjust mantissa based on difference from nearest power
                      const powerDiff = nearestPower - absExponent;
                      const adjustedMantissa = parseFloat(mantissaSimple) * Math.pow(10, powerDiff);
                      return `${adjustedMantissa.toFixed(4)} ${word}`;
                  }
                  
                  return getNumberWord(power);
              }
              case 'full': {
                  // Lower the threshold for switching to exponential
                  if (Math.abs(value) < 1e-18) {
                      return value.toExponential(4);
                  } else {
                      return new Intl.NumberFormat('en-US', {
                          minimumFractionDigits: 4,
                          maximumFractionDigits: 18 // Increased precision
                      }).format(value);
                  }
              }
              case 'scientific': {
                  const expSci = value.toExponential();
                  const [mantissaSci, exponentSci] = expSci.split('e');
                  const formattedMantissa = parseFloat(mantissaSci).toFixed(4);
                  return `${formattedMantissa} × 10<sup>${parseInt(exponentSci)}</sup>`;
              }
              default:
                  return value.toString();
          }
      }

      // function to generate chord data
      // This function creates the data structure for the chord diagram
      function generatechartData(sectors, indicators, total, byIndicator) {
          const nodes = [
              // Add sectors as nodes, i.e. arrays of all elements
              ...sectors.map(s => ({
                  id: s.code,
                  name: s.name,
                  type: 'sector',
                  group: 1
              })),
              // Add indicators as nodes
              ...indicators.map(i => ({
                  id: i.code,
                  name: i.name || i.code,
                  type: 'indicator',
                  group: 2
              }))
          ];

          const links = [];
          sectors.forEach(sector => {
              indicators.forEach(indicator => {
                  const value = Math.abs(byIndicator[indicator.code][sector.index]);
                  if (value > 0) {
                      links.push({
                          source: sector.code,
                          target: indicator.code,
                          value: value
                      });
                  }
              });
          });

          return {
              nodes: nodes,
              links: links
          };
      }

      // Create initial table with sorted data
      function initializeTable(formatType) {
          const tableConfig = {
              data: isShowingAllRows ? allResults : sortedResults,
              layout: "fitColumns",
              initialSort: [{column: "total", dir: "desc"}], // Use total for initial sorting
              columns: [
                  { 
                      title: "Sector", 
                      field: "sector", 
                      width: 300,
                      formatter: "html",
                      headerSortStartingDir: "desc", // Set default sort direction to descending
                      headerClick: function(e, column) {
                          if (!isShowingAllRows) {
                              isShowingAllRows = true;
                              table.setData(allResults);
                              showAllLink.style.display = 'none';
                          }
                      }
                  },
                  { 
                      title: "Total Score", 
                      field: "total",
                      width: 180,
                      sorter: "number", // Add numeric sorter
                      formatter: function(cell) {
                          return formatNumber(cell.getValue(), formatType);
                      },
                      headerSortStartingDir: "desc", // Set default sort direction to descending
                      headerClick: function(e, column) {
                          if (!isShowingAllRows) {
                              isShowingAllRows = true;
                              table.setData(allResults);
                              showAllLink.style.display = 'none';
                          }
                      }
                  }
              ]
          };

          // Modify indicator columns to include descending sort direction
          indicators.slice(0, 10).forEach(indicator => {
              tableConfig.columns.push({
                  title: indicator.code,
                  field: indicator.code,
                  width: 160,
                  sorter: "number", // Add numeric sorter
                  headerSortStartingDir: "desc", // Set default sort direction to descending
                  formatter: function(cell) {
                      return formatNumber(cell.getValue(), formatType);
                  },
                  headerClick: function(e, column) {
                      if (!isShowingAllRows) {
                          isShowingAllRows = true;
                          table.setData(allResults);
                          showAllLink.style.display = 'none';
                      }
                  }
              });
          });

          return new Tabulator("#table", tableConfig);
      }

      let isShowingAllRows = false;

      // Initialize table with simple format by default
      let table = initializeTable('simple');
      
      // Set initial data state
      currentData = sortedResults;

      // Modify the format change listener
      const formatSelect = document.getElementById('number-format-select');
      formatSelect.addEventListener('change', function() {
          const currentFormat = this.value;
          table.destroy();
          table = initializeTable(currentFormat);
          
          // Always use the correct dataset based on state
          if (isShowingAllRows) {
              table.setData(allResults);
          } else {
              table.setData(sortedResults);
          }
          
          // Always update link visibility based on state
          document.getElementById('showAllLink').style.display = 
              isShowingAllRows ? 'none' : 'inline-block';
      });

      // Modify the show all link handler
      const showAllLink = document.getElementById('showAllLink');
      showAllLink.addEventListener('click', function(e) {
          e.preventDefault();
          isShowingAllRows = true;
          table.setData(allResults);
          this.style.display = 'none';
          
          setTimeout(() => {
              table.scrollToRow(table.getRows()[table.getRows().length - 1], "bottom", true);
          }, 100);
      });

      // Ensure link is visible for new state data
      showAllLink.style.display = 'inline-block';
      currentData = sortedResults;
      isShowingAllRows = false;

      // Updating the main() function to generate chord data
      chartData = generatechartData(sectors, indicators, total, byIndicator);
      
      // Console logging structure for debugging
      console.log('Chord data generated:', chartData);

      try {
        // Sort and limit data for consistent chord diagram display
        console.log(`Total sectors: ${results.length}, limiting to top 10 for chord diagram`);
        
        // Ensure results are sorted by total impact (descending)
        const sortedResults = [...results].sort((a, b) => b.sortValue - a.sortValue);
        
        // Debug: Check all sector names before filtering
        console.log(`All sectors from results (first 15):`, sortedResults.slice(0, 15).map(s => s.sector));
        
        // Get unique sectors (avoid duplicate sector names)
        const uniqueSectors = [];
        const seenSectors = new Set();
        
        for (const result of sortedResults) {
            if (!seenSectors.has(result.sector) && uniqueSectors.length < 10) {
                uniqueSectors.push(result);
                seenSectors.add(result.sector);
            }
        }
        
        console.log(`Found ${uniqueSectors.length} unique sectors out of ${sortedResults.length} total results`);
        console.log(`Unique sectors:`, uniqueSectors.map(s => s.sector));
        console.log(`First few sorted results:`, sortedResults.slice(0, 5).map(s => ({ sector: s.sector, sortValue: s.sortValue.toFixed(3) })));
        
        const top10Results = uniqueSectors;
        
        // Sort indicators alphabetically for consistent display
        const sortedIndicators = [...indicators].sort((a, b) => a.code.localeCompare(b.code));
        console.log(`Total indicators: ${sortedIndicators.length}, limiting to top 10 for chord diagram`);
        const top10Indicators = sortedIndicators.slice(0, 10);
        
        // Store data globally for dropdown changes
        window.currentChordData = { sectors: top10Results, indicators: top10Indicators };
        
  // Load saved preferences for initial chart creation
  const initialPrefs = window.ChartPreferences ? window.ChartPreferences.load() : { scalingMethod: 'raw', edgeStyle: 'light' };

  // Create a shared colorScale so chord and sankey share colors
  const allSectorIds = top10Results.map(s => s.metadata ? (s.metadata.NAICS || s.sector) : s.sector);
  const sharedColorScale = d3.scaleOrdinal(d3.schemeCategory10).domain(allSectorIds);
        
        // Hide containers to prevent initial small->big flicker
        try {
          document.getElementById('chart2').style.visibility = 'hidden';
          document.getElementById('sankey').style.visibility = 'hidden';
        } catch (e) {}

        // Initialize chord and capture the returned ChordDiagram instance so we can post-process labels
        const chordInstance = await initializeChordDiagram(top10Results, top10Indicators, { 
          containerId: '#chart2',
          scalingMethod: initialPrefs.scalingMethod,
          chordBorder: {
            style: initialPrefs.edgeStyle,
            width: '1px'
          },
          colorScale: sharedColorScale
        });

  // Using default chord script styling; custom label post-processing removed.

        // After the chord finishes rendering, extract its actual colors from the DOM
        // and pass a color function to the Sankey so both charts use identical colors.
        if (typeof initializeSankey === 'function') {
          // Allow the chord renderer a short moment to paint
          setTimeout(() => {
            try {
              // Build a mapping from node id -> computed color by matching label text in #chart2
              const colorMap = {};
              const svg = document.querySelector('#chart2 svg');
              if (svg) {
                // For each sector id, try to find a text node that matches the sector name and read color
                top10Results.forEach(s => {
                  const id = s.metadata ? (s.metadata.NAICS || s.sector) : s.sector;
                  // Find text element containing the sector name
                  const textEl = Array.from(svg.querySelectorAll('text')).find(t => (t.textContent || '').trim() === s.sector);
                        if (textEl) {
                          // Prefer the fill attribute of the nearest sibling shape (may be a gradient url)
                          let color = null;
                          const gp = textEl.closest('g');
                          if (gp) {
                            const shape = gp.querySelector('path, rect, circle');
                            if (shape) {
                              // check the literal fill attribute first (may be 'url(#grad)')
                              const fillAttr = shape.getAttribute && shape.getAttribute('fill');
                              if (fillAttr && fillAttr.indexOf('url(') === 0) {
                                // extract gradient id and copy its definition so sankey can reference it
                                const m = fillAttr.match(/url\(#([^\)]+)\)/);
                                if (m) {
                                  const gradId = m[1];
                                  // copy gradient <defs> node into a hidden host if not already present
                                  try {
                                    if (!document.getElementById(gradId)) {
                                      const defNode = svg.querySelector(`#${gradId}`);
                                      if (defNode) {
                                        let host = document.getElementById('chart2-gradient-host');
                                        if (!host) {
                                          host = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                                          host.setAttribute('id', 'chart2-gradient-host');
                                          host.style.position = 'absolute';
                                          host.style.left = '0';
                                          host.style.top = '0';
                                          host.style.width = '0';
                                          host.style.height = '0';
                                          document.body.appendChild(host);
                                        }
                                        host.appendChild(defNode.cloneNode(true));
                                      }
                                    }
                                  } catch (e) {
                                    // ignore clone errors
                                  }
                                  color = `url(#${m[1]})`;
                                }
                              }
                              // if we didn't find a gradient, fall back to computed styles
                              if (!color) color = window.getComputedStyle(shape).fill || window.getComputedStyle(shape).stroke;
                            }
                          }
                          if (!color) color = window.getComputedStyle(textEl).fill;
                          if (color) colorMap[id] = color;
                        }
                });
              }

              // Create a color function that prefers the extracted map, falling back to sharedColorScale
              const inferredColorScale = function(id) {
                if (colorMap && colorMap[id]) return colorMap[id];
                try { return sharedColorScale(id); } catch (e) { return '#999'; }
              };

              const initialPrefs = window.ChartPreferences ? window.ChartPreferences.load() : { scalingMethod: 'raw', edgeStyle: 'light' };
              initializeSankey(top10Results, top10Indicators, { containerId: '#sankey', scalingMethod: initialPrefs.scalingMethod, edgeStyle: initialPrefs.edgeStyle, themeMode: initialPrefs.themeMode, colorScale: inferredColorScale });
            } catch (e) {
              // fallback to shared scale if extraction failed
              const initialPrefs = window.ChartPreferences ? window.ChartPreferences.load() : { scalingMethod: 'raw', edgeStyle: 'light' };
              initializeSankey(top10Results, top10Indicators, { containerId: '#sankey', scalingMethod: initialPrefs.scalingMethod, edgeStyle: initialPrefs.edgeStyle, themeMode: initialPrefs.themeMode, colorScale: sharedColorScale });
            }
          }, 120);
        }

        // Show containers after render
        try {
          document.getElementById('chart2').style.visibility = 'visible';
          document.getElementById('sankey').style.visibility = 'visible';
        } catch (e) {}
        
        // Display debug info for consistency checking
        displayDebugInfo(top10Results, top10Indicators);
      } catch (error) {
        console.error('Error creating chord diagram:', error);
      }

    }

    // Debug function to display the sorted lists
    function displayDebugInfo(sectors, indicators) {
      const sectorsDiv = document.getElementById('sectors-list');
      const indicatorsDiv = document.getElementById('indicators-list');
      
      // Display sectors list
      sectorsDiv.innerHTML = `
        <h5>Top 10 Sectors (sorted by impact, descending):</h5>
        <ol>
          ${sectors.map((s, i) => `<li>${s.sector}</li>`).join('')}
        </ol>
      `;
      
      // Display indicators list
      indicatorsDiv.innerHTML = `
        <h5>Indicators (sorted alphabetically by code):</h5>
        <ol>
          ${indicators.map(ind => `<li>${ind.code} - ${ind.name || 'No name'}</li>`).join('')}
        </ol>
      `;
      
      // Display the matrix data (sector-indicator amounts)
      const matrixDiv = document.createElement('div');
      
      // Calculate column totals
      const columnTotals = indicators.map(ind => {
        return sectors.reduce((sum, sector) => {
          const value = sector[ind.code];
          return sum + (value !== undefined ? Math.abs(value) : 0);
        }, 0);
      });
      
      matrixDiv.innerHTML = `
        <h5>Sector-Indicator Values Matrix:</h5>
        <table style="border-collapse: collapse; margin-top: 10px; font-size: 10px;">
          <thead>
            <tr>
              <th style="border: 1px solid #ccc; padding: 4px;">Sector</th>
              ${indicators.map(ind => `<th style="border: 1px solid #ccc; padding: 4px; writing-mode: vertical-rl; text-orientation: mixed; min-width: 30px;">${ind.code}</th>`).join('')}
              <th style="border: 1px solid #ccc; padding: 4px; font-weight: bold;">Row Total</th>
            </tr>
          </thead>
          <tbody>
            ${sectors.map(sector => {
              // Calculate row total
              const rowTotal = indicators.reduce((sum, ind) => {
                const value = sector[ind.code];
                return sum + (value !== undefined ? Math.abs(value) : 0);
              }, 0);
              
              return `
              <tr>
                <td style="border: 1px solid #ccc; padding: 4px; font-weight: bold; max-width: 200px; overflow: hidden; text-overflow: ellipsis;">${sector.sector}</td>
                ${indicators.map(ind => {
                  const value = sector[ind.code];
                  return `<td style="border: 1px solid #ccc; padding: 4px; text-align: right;">${value !== undefined ? value.toFixed(3) : 'N/A'}</td>`;
                }).join('')}
                <td style="border: 1px solid #ccc; padding: 4px; text-align: right; font-weight: bold;">${rowTotal.toFixed(3)}</td>
              </tr>
              `;
            }).join('')}
            <tr style="font-weight: bold;">
              <td style="border: 1px solid #ccc; padding: 4px;">Column Total</td>
              ${columnTotals.map(total => `<td style="border: 1px solid #ccc; padding: 4px; text-align: right;">${total.toFixed(3)}</td>`).join('')}
              <td style="border: 1px solid #ccc; padding: 4px;"></td>
            </tr>
          </tbody>
        </table>
      `;
      
      // Append matrix after indicators list
      indicatorsDiv.appendChild(matrixDiv);
    }

    // Chart preferences management with localStorage
    const ChartPreferences = {
      // Default values
      defaults: {
        scalingMethod: 'raw',
        edgeStyle: 'light',
        themeMode: 'light'
      },
      
      // Save preferences to localStorage
      save: function(scalingMethod, edgeStyle, themeMode) {
        const prefs = {
          scalingMethod: scalingMethod || this.defaults.scalingMethod,
          edgeStyle: edgeStyle || this.defaults.edgeStyle,
          themeMode: themeMode || this.defaults.themeMode,
          timestamp: Date.now()
        };
        localStorage.setItem('chartPreferences', JSON.stringify(prefs));
        console.log('Chart preferences saved:', prefs);
      },
      
      // Load preferences from localStorage
      load: function() {
        try {
          const stored = localStorage.getItem('chartPreferences');
          if (stored) {
            const prefs = JSON.parse(stored);
            console.log('Chart preferences loaded:', prefs);
            return {
              scalingMethod: prefs.scalingMethod || this.defaults.scalingMethod,
              edgeStyle: prefs.edgeStyle || this.defaults.edgeStyle,
              themeMode: prefs.themeMode || this.defaults.themeMode
            };
          }
        } catch (error) {
          console.warn('Error loading chart preferences:', error);
        }
        return this.defaults;
      },
      
      // Apply preferences to dropdowns
      applyToDropdowns: function(scalingSelect, edgeSelect, themeSelect) {
        const prefs = this.load();
        if (scalingSelect && scalingSelect.value !== prefs.scalingMethod) {
          scalingSelect.value = prefs.scalingMethod;
        }
        if (edgeSelect && edgeSelect.value !== prefs.edgeStyle) {
          edgeSelect.value = prefs.edgeStyle;
        }
        if (themeSelect && themeSelect.value !== prefs.themeMode) {
          themeSelect.value = prefs.themeMode;
        }
        return prefs;
      }
    };
    
    // Make ChartPreferences globally available for other pages
    window.ChartPreferences = ChartPreferences;

    main();

    // Add event listeners for control dropdowns
    document.addEventListener('DOMContentLoaded', function() {
      const scalingSelect = document.getElementById('scaling-method');
      const edgeSelect = document.getElementById('edge-style');
      const themeSelect = document.getElementById('theme-mode');
      
      // Load and apply saved preferences on page load
      const savedPrefs = ChartPreferences.applyToDropdowns(scalingSelect, edgeSelect, themeSelect);
      console.log('Applied saved chart preferences:', savedPrefs);
      
      // Apply theme mode on page load if setSitelook function exists
      if (typeof setSitelook === 'function') {
        setSitelook(savedPrefs.themeMode);
      }
      
      function updateChordDiagram() {
        if (window.currentChordData) {
          const selectedScaling = scalingSelect ? scalingSelect.value : savedPrefs.scalingMethod;
          const selectedEdge = edgeSelect ? edgeSelect.value : savedPrefs.edgeStyle;
          const selectedTheme = themeSelect ? themeSelect.value : savedPrefs.themeMode;
          
          // Save preferences whenever they change
          ChartPreferences.save(selectedScaling, selectedEdge, selectedTheme);
          
          console.log(`Updating chart - Scaling: ${selectedScaling}, Edge: ${selectedEdge}`);
          
          try {
            const updatedChord = initializeChordDiagram(
              window.currentChordData.sectors, 
              window.currentChordData.indicators, 
              { 
                containerId: '#chart2',
                scalingMethod: selectedScaling,
                chordBorder: {
                  style: selectedEdge,
                  width: "1px"
                }
              }
            );

            // If initializeChordDiagram returned a promise or instance, leave default labeling
            Promise.resolve(updatedChord).then(inst => {}).catch(() => {});

            // Also update Sankey when controls change
            if (typeof initializeSankey === 'function') {
              initializeSankey(window.currentChordData.sectors, window.currentChordData.indicators, { containerId: '#sankey', scalingMethod: selectedScaling, edgeStyle: selectedEdge });
            }
          } catch (error) {
            console.error('Error updating chord diagram:', error);
          }
        }
      }
      
      if (scalingSelect) {
        scalingSelect.addEventListener('change', updateChordDiagram);
      }
      
      if (edgeSelect) {
        edgeSelect.addEventListener('change', updateChordDiagram);
      }
      
      if (themeSelect) {
        themeSelect.addEventListener('change', function() {
          const selectedTheme = this.value;
          console.log(`Theme changed to: ${selectedTheme}`);
          
          // Apply theme change using setSitelook function if available
          if (typeof setSitelook === 'function') {
            setSitelook(selectedTheme);
          }
          
          // Update preferences and chart
          updateChordDiagram();
        });
      }
      
      // Trigger initial update with saved preferences if data is already loaded
      if (window.currentChordData) {
        updateChordDiagram();
      }
    });

    // Initialize Sankey using the repository's sk.createSankey implementation
    function initializeSankey(sectors, indicators, options) {
            try {
                const containerId = options && options.containerId ? options.containerId : '#sankey';
                const container = d3.select(containerId);
                container.selectAll('*').remove();

  // Use the same node/link ids and attributes as the chord chart
  // Nodes: sector NAICS (or name) and indicator.code
  const sectorIds = sectors.map(s => s.metadata ? (s.metadata.NAICS || s.sector) : s.sector);
  // Prefer a shared colorScale passed in options (from chord); fall back to local scale
  const colorScale = options && options.colorScale ? options.colorScale : d3.scaleOrdinal(d3.schemeCategory10).domain(sectorIds);

        const nodes = [];
        const links = [];

        // Add sector nodes with id equal to NAICS (if available) otherwise the sector name
        sectors.forEach((s) => {
          const id = s.metadata ? (s.metadata.NAICS || s.sector) : s.sector;
          nodes.push({ id: id, name: s.sector, color: colorScale(id), type: 'sector' });
        });

        // Add indicator nodes with id equal to indicator code
        indicators.forEach((ind) => {
          nodes.push({ id: ind.code, name: ind.code, color: '#999', type: 'indicator' });
        });

        // Create links using id strings so the repo sankey (and chord) share semantics
        sectors.forEach((s) => {
          const sourceId = s.metadata ? (s.metadata.NAICS || s.sector) : s.sector;
          indicators.forEach((ind) => {
            const val = Math.abs(s[ind.code] || 0);
            if (val > 0) {
              links.push({ source: sourceId, target: ind.code, value: val });
            }
          });
        });

          const width = container.node().clientWidth || 600;
          const height = container.node().clientHeight || 480;

    // Determine scaling method, edge style and theme mode
    const scalingMethod = options && options.scalingMethod ? options.scalingMethod : 'raw';
    const edgeStyle = options && options.edgeStyle ? options.edgeStyle : 'light';
    const themeMode = options && options.themeMode ? options.themeMode : (window.ChartPreferences ? window.ChartPreferences.load().themeMode : 'light');

                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);

        // Build sankeyData using id/name/color/value so it matches the chord data semantics
        const sankeyData = {
          nodes: nodes.map(n => ({ id: n.id, name: n.name, color: n.color })),
          links: links.map(l => ({ source: l.source, target: l.target, value: l.value }))
        };

                const layout = d3.sankey()
                    .nodeWidth(12)
                    .nodePadding(8)
                    .extent([[1, 1], [width - 1, height - 6]]);

                // Apply scaling to link values before layout
                const scaledLinks = sankeyData.links.map(l => {
                  let v = l.value;
                  switch (scalingMethod) {
                    case 'square-root': v = Math.sqrt(v); break;
                    case 'proportional': v = v; break;
                    case 'logarithmic': v = (v > 0) ? Math.log10(v + 1) : 0; break;
                    default: v = v; // raw
                  }
                  return Object.assign({}, l, { value: v });
                });

                // d3-sankey expects link.source and link.target to be node indices or node objects.
                // Convert string ids to node objects the layout can consume.
                const nodeById = new Map(sankeyData.nodes.map(n => [n.id, Object.assign({}, n)]));
                const layoutLinks = scaledLinks.map(l => {
                  const s = nodeById.get(l.source);
                  const t = nodeById.get(l.target);
                  return Object.assign({}, l, { source: s, target: t });
                });

                // The layout needs an array of node objects; ensure we pass copies
                const graph = layout({ nodes: Array.from(nodeById.values()), links: layoutLinks });
                const path = d3.sankeyLinkHorizontal();

                const linkG = svg.append('g')
                    .attr('fill', 'none')
                    .selectAll('g')
                    .data(graph.links)
                    .join('g');

                // Path for the link
                linkG.append('path')
                    .attr('d', path)
                    .attr('stroke', d => {
                      // Prefer explicit shared colorScale if provided; otherwise fall back to node color
                      if (options && options.colorScale && d.source && d.source.id) return options.colorScale(d.source.id);
                      return d.source && d.source.color ? d.source.color : '#999';
                    })
                    .attr('stroke-opacity', edgeStyle === 'none' ? 0 : (edgeStyle === 'dark' ? 0.95 : 0.6))
                    .attr('stroke-width', d => {
                      const base = Math.max(1, d.width);
                      // scale link width visually depending on scaling method
                      return Math.max(1, base);
                    })
                    .attr('fill', 'none')
                    .attr('stroke-linecap', 'round');
                
        // Add tooltip on hover using the page's #chord-tooltip div so the same popup works for other charts
        const tooltip = d3.select('#chord-tooltip');

        linkG.on('mouseover', function(event, d) {
          tooltip.style('opacity', 1)
               .html(`<strong>${d.source.name} → ${d.target.name}</strong><br/>Value: ${d.value.toFixed ? d.value.toFixed(3) : d.value}`);
          const [mx, my] = d3.pointer(event, document.body);
          tooltip.style('left', (mx + 12) + 'px')
               .style('top', (my + 12) + 'px');
        })
        .on('mousemove', function(event) {
          const [mx, my] = d3.pointer(event, document.body);
          tooltip.style('left', (mx + 12) + 'px')
               .style('top', (my + 12) + 'px');
        })
        .on('mouseleave', function() {
          tooltip.style('opacity', 0);
        });

                // Add text on the path
                linkG.append('text')
                    .attr('x', d => (d.source.x1 + d.target.x0) / 2)
                    .attr('y', d => (d.y0 + d.y1) / 2)
                    .attr('dy', '0.35em')
                    .attr('text-anchor', 'middle')
                    .style('font-size', '10px')
                    .text(d => d.value);

                const nodeG = svg.append('g')
                    .selectAll('g')
                    .data(graph.nodes)
                    .join('g');

                nodeG.append('rect')
                    .attr('x', d => d.x0)
                    .attr('y', d => d.y0)
                    .attr('height', d => Math.max(1, d.y1 - d.y0))
                    .attr('width', d => Math.max(1, d.x1 - d.x0))
                  .attr('fill', d => {
                    if (options && options.colorScale && d.id) return options.colorScale(d.id);
                    return d.color || '#999';
                  })
                  .attr('stroke', d => {
                    if (edgeStyle === 'none') return 'none';
                    if (edgeStyle === 'dark') return d3.rgb(d.color || '#999').darker(2.2);
                    return d3.rgb(d.color || '#999').darker(1.2);
                  })
                  .attr('stroke-width', edgeStyle === 'none' ? 0 : 1);

        nodeG.append('text')
                  .attr('x', d => d.x0 < width / 2 ? d.x1 + 6 : d.x0 - 6)
                  .attr('y', d => (d.y1 + d.y0) / 2)
                  .attr('dy', '0.35em')
                  .attr('text-anchor', d => d.x0 < width / 2 ? 'start' : 'end')
                  .text(function(d) {
                    // In dark mode, hide numeric-only labels (e.g., NAICS codes)
                    if (themeMode === 'dark') {
                      if (/^\d+$/.test(String(d.name).trim())) return '';
                    }
                    return d.name;
                  })
                  .style('font-size', '11px');

        // Node hover tooltip
        nodeG.on('mouseover', function(event, d) {
          tooltip.style('opacity', 1)
               .html(`<strong>${d.name}</strong><br/>In: ${d.value ? d.value.toFixed ? d.value.toFixed(3) : d.value : 'N/A'}<br/>Out: ${d.value ? d.value.toFixed ? d.value.toFixed(3) : d.value : 'N/A'}`);
          const [mx, my] = d3.pointer(event, document.body);
          tooltip.style('left', (mx + 12) + 'px')
               .style('top', (my + 12) + 'px');
        })
        .on('mousemove', function(event) {
          const [mx, my] = d3.pointer(event, document.body);
          tooltip.style('left', (mx + 12) + 'px')
               .style('top', (my + 12) + 'px');
        })
        .on('mouseleave', function() {
          tooltip.style('opacity', 0);
        });

            } catch (err) {
                console.error('Error in initializeSankey:', err);
            }
        }

  </script>


<style>
line {
  stroke: #000;
  stroke-width: 1.px;
}
path.chord {
  fill-opacity: .80;
}
.title {
  text-anchor: middle;
  fill: #3B3B3B;
  font-weight: bold;
  font-size: 16px;
}
.titleLine {
  stroke: #DCDCDC;
  shape-rendering: crispEdges;
}

/* Dark mode styling */
.dark .title {
  fill: white;
}
.dark .titleLine {
  stroke: #666;
}
.dark text.titles {
  fill: white;
}
.dark svg text,
.dark #sankey svg text,
.dark #chart2 svg text,
.dark .sk-node text {
  fill: white !important;
}
.dark #sankey svg .sk-node rect {
  stroke-opacity: 0.9;
}
.dark #scaling-method,
.dark #edge-style {
  background: #333;
  color: white;
  border-color: #555;
}
.dark #scaling-method option,
.dark #edge-style option {
  background: #333;
  color: white;
}

/* Dark mode for matrix table */
.dark #chart2-debug {
  color: white;
}
.dark #chart2-debug table {
  border-color: #555;
}
.dark #chart2-debug th,
.dark #chart2-debug td {
  border-color: #555;
  color: white;
}    
</style>

<div class="content" style="padding:0px">

<!-- Tooltip for chart hover effects -->
<div id="chord-tooltip" style="position: absolute; background: rgba(0,0,0,0.8); color: white; padding: 8px 12px; border-radius: 4px; font-size: 12px; pointer-events: none; z-index: 1000; opacity: 0; transition: opacity 0.2s;"></div>

<!-- Debug output for chart2 data -->
<div id="chart2-debug">
  <h4>Chord Chart Data:</h4>
  <div id="sectors-list"></div>
  <div id="indicators-list"></div>
</div>
<svg height="0cm" width="0cm">
  <defs>
    <linearGradient id="gradientLinear" x1="-100%" y1="0%" x2="100%" y2="0%" gradientUnits="userSpaceOnUse">
      <stop offset="-100%" stop-color="#858585" stop-opacity=".5">
        <animate attributeName="offset" values="-1;0" dur="5s" repeatCount="indefinite"></animate>
      </stop>
      
      <stop offset="-75%" stop-color="#BEBEBE" stop-opacity=".5">
        <animate attributeName="offset" values="-0.75;0.25" dur="5s" repeatCount="indefinite"></animate>
      </stop>
      
      <stop offset="-50%" stop-color="#858585" stop-opacity=".5">
        <animate attributeName="offset" values="-0.5;0.5" dur="5s" repeatCount="indefinite"></animate>
      </stop>
      
      <stop offset="-25%" stop-color="#BEBEBE" stop-opacity=".5">
        <animate attributeName="offset" values="-0.25;0.75" dur="5s" repeatCount="indefinite"></animate>
      </stop>
      
      <stop offset="0%" stop-color="#858585" stop-opacity=".5">
        <animate attributeName="offset" values="0;1" dur="5s" repeatCount="indefinite"></animate>
      </stop>
      
      <stop offset="25%" stop-color="#BEBEBE" stop-opacity=".5">
        <animate attributeName="offset" values="0.25;1.25" dur="5s" repeatCount="indefinite"></animate>
      </stop>
      
      <stop offset="50%" stop-color="#858585" stop-opacity=".5">
        <animate attributeName="offset" values="0.5;1.5" dur="5s" repeatCount="indefinite"></animate>
      </stop>   
      
      <stop offset="75%" stop-color="#BEBEBE" stop-opacity=".5">
        <animate attributeName="offset" values="0.75;1.75" dur="5s" repeatCount="indefinite"></animate>
      </stop>
      
      <stop offset="100%" stop-color="#858585" stop-opacity=".5">
        <animate attributeName="offset" values="1;2" dur="5s" repeatCount="indefinite"></animate>
      </stop>
    </linearGradient>
  </defs>
</svg>
<br>

About <a href="chord/">Stretched Chord Chart</a> and <a href="/io/charts/sankey/">Sankey Chart</a><br>
<br>

<!--
Use the stand-alone <a href="chord/stretched">cord/stretched</a> for dev.<br>
-->

<!--
TODO: Horizontal Titles - Add angled lines where the titles currently reside.<br>
Have each angled line connect to a horizontal line that travels under each title.<br>
-->


</div>

</body>
</html>