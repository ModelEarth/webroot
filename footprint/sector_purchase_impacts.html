<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <title>Sector Analysis - Impacts of purchases</title>
  <link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link href="https://unpkg.com/tabulator-tables@5.2.7/dist/css/tabulator.min.css" rel="stylesheet">
  <script type="text/javascript" src="https://unpkg.com/tabulator-tables@5.2.7/dist/js/tabulator.min.js"></script>

  <script type="text/javascript" src="https://model.earth/localsite/js/localsite.js?showheader=true&showsearch=true"></script>
  <script src="../dist/useeio.js"></script>
  <style>
    #table {
      margin: 20px 0;
      height: auto !important;
    }
    .tabulator-cell {
      white-space: normal;
      overflow: visible;
      padding: 8px;
    }
    .tabulator .tabulator-header .tabulator-col {
      background-color: #f4f4f4;
    }
    .tabulator-tableholder {
      height: auto !important;
      min-height: 0 !important;
    }
    .tabulator {
      height: auto !important;
    }
  </style>
</head>

<body>
  <div style="padding-left:60px;padding-right:18px;">
    <div style="margin-bottom:10px">
        <a id="footprintLink" href="./" >State Impact Reports</a>
    </div>
    <div id="relocatedStateMenu"></div>
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <p id="info" style="margin: 0;">Loading ...</p>
        <select id="number-format-select" style="margin-left: 10px;">
            <option value="simple" selected>simple</option>
            <option value="full">full</option>
            <option value="scientific">scientific</option>
        </select>
    </div>
    <div id="table"></div>
    <a href="#" id="showAllLink" style="display:block; margin: 10px 0 20px 0;">Show all rows</a>
  </div>

  <script src="./config.js"></script>
  <script>
    // Update the global variables at the top
    let isShowingAllRows = false;
    let table;
    let currentData = null;
    let allResults = null;

    document.addEventListener('hashChangeEvent', hashChangedUseeio, false);
    
    // Update the hashChangedUseeio function to reset state
    function hashChangedUseeio() {
      console.log("URL hash changed");
      model = getModel();
      isShowingAllRows = false; // Reset the state
      currentData = null;
      
      // Reset format to simple when state changes
      const formatSelect = document.getElementById('number-format-select');
      formatSelect.value = 'simple';
      
      // Reset show all link visibility
      const showAllLink = document.getElementById('showAllLink');
      showAllLink.style.display = 'block';
      
      main();
    }

    function formatNumber(value, formatType) {
        // Handle true zero or undefined values
        if (value === 0 || !value) {
            return '0.0000';
        }
        
        switch(formatType) {
            case 'simple': {
                // Update threshold to 1e-33 for decillionth
                if (Math.abs(value) < 1e-33) {
                    return value.toExponential(4);
                }
                
                const expSimple = value.toExponential();
                const [mantissaSimple, exponentSimple] = expSimple.split('e');
                const power = parseInt(exponentSimple);
                
                function getNumberWord(power) {
                    const words = {
                        0: '',
                        3: 'thousand',
                        6: 'million',
                        9: 'billion',
                        12: 'trillion',
                        15: 'quadrillion',
                        18: 'quintillion',
                        21: 'sextillion',
                        24: 'septillion',
                        27: 'octillion',
                        30: 'nonillion',
                        33: 'decillion',
                        '-1': 'tenth',
                        '-2': 'hundredth',
                        '-3': 'thousandth',
                        '-6': 'millionth',
                        '-9': 'billionth',
                        '-12': 'trillionth',
                        '-15': 'quadrillionth',
                        '-18': 'quintillionth',
                        '-21': 'sextillionth',
                        '-24': 'septillionth',
                        '-27': 'octillionth',
                        '-30': 'nonillionth',
                        '-33': 'decillionth'
                    };

                    // Handle numbers with no exponent or small positive exponents
                    if (power >= 0 && power < 3) {
                        const adjustedValue = parseFloat(mantissaSimple) * Math.pow(10, power);
                        return adjustedValue.toFixed(4);
                    }

                    // Update threshold for extremely small numbers
                    if (power < -33) {
                        return value.toExponential(4);
                    }

                    // Rest of the getNumberWord function remains the same
                    if (power < 0 && power > -3) {
                        const word = words[power];
                        if (word) {
                            const adjustedMantissa = parseFloat(mantissaSimple) * Math.pow(10, -power);
                            return `${adjustedMantissa.toFixed(4)} ${word}`;
                        }
                    }

                    const absExponent = Math.abs(power);
                    let nearestPower;
                    if (power < 0) {
                        nearestPower = Math.ceil(absExponent / 3) * 3;
                    } else {
                        nearestPower = Math.floor(absExponent / 3) * 3;
                    }
                    
                    const word = words[power > 0 ? nearestPower : -nearestPower];
                    
                    if (!word) return value.toExponential(4);
                    
                    const powerDiff = nearestPower - absExponent;
                    const adjustedMantissa = parseFloat(mantissaSimple) * Math.pow(10, powerDiff);
                    return `${adjustedMantissa.toFixed(4)} ${word}`;
                }
                
                return getNumberWord(power);
            }
            case 'full': {
                if (Math.abs(value) < 1e-18) {
                    return value.toExponential(4);
                } else {
                    return new Intl.NumberFormat('en-US', {
                        minimumFractionDigits: 4,
                        maximumFractionDigits: 18
                    }).format(value);
                }
            }
            case 'scientific': {
                const expSci = value.toExponential();
                const [mantissaSci, exponentSci] = expSci.split('e');
                const formattedMantissa = parseFloat(mantissaSci).toFixed(4);
                return `${formattedMantissa} Ã— 10<sup>${parseInt(exponentSci)}</sup>`;
            }
            default:
                return value.toString();
        }
    }

    async function main() {
      let hash = getUrlHash();
      const info = document.getElementById("info");
      const demandId = await model.findDemand({
        system: "Complete",
        type: "Consumption",
      });
      if (!demandId) {
        info.textContent = "Failed to load demand";
        return;
      }

      const sectors = await model.sectors();
      const i = Math.round(Math.random() * (sectors.length - 1));
      const sector = sectors[i];
      info.textContent = `Analyzing sector '${sector.name}' based on ${demandId}`;

      const analysis = await useeio.SectorAnalysis.of(model, sector, demandId);
      const indicators = await model.indicators();

      const total = await analysis.getPurchaseImpacts(indicators);
      const byIndicator = {};
      for (const indicator of indicators) {
        byIndicator[indicator.code] = await analysis.getPurchaseImpacts(indicator);
      }
      
      const results = [];
      for (const sector of sectors) {
        const rawTotal = Math.abs(total[sector.index]);
        const result = {
          sector: `${sector.code} - ${sector.name}`,
          total: rawTotal,
          totalRaw: rawTotal, // Add raw value for sorting
          sortValue: rawTotal // Explicit sort value
        };
        indicators.forEach(i => {
          const value = byIndicator[i.code][sector.index];
          result[i.code] = value;
          // Add raw values for indicators for proper sorting
          result[i.code + '_raw'] = value;
        });
        results.push(result);
      }

      // Sort and store results
      const allResults = results.sort((a, b) => b.sortValue - a.sortValue);
      const sortedResults = allResults.slice(0, 20); // Changed from 10 to 20

      function initializeTable(formatType) {
        const tableConfig = {
            data: isShowingAllRows ? allResults : sortedResults,
            layout: "fitColumns",
            initialSort: [{column: "total", dir: "desc"}],
            columns: [
                { 
                    title: "Sector", 
                    field: "sector", 
                    width: 300,
                    formatter: "html",
                    headerSortStartingDir: "desc",
                    headerClick: function(e, column) {
                        if (!isShowingAllRows) {
                            isShowingAllRows = true;
                            table.setData(allResults);
                            showAllLink.style.display = 'none';
                        }
                    }
                },
                { 
                    title: "Total Score", 
                    field: "total",
                    width: 180,
                    sorter: "number",
                    sortField: "totalRaw",
                    formatter: function(cell) {
                        return formatNumber(cell.getValue(), formatType);
                    },
                    headerSortStartingDir: "desc",
                    headerClick: function(e, column) {
                        if (!isShowingAllRows) {
                            isShowingAllRows = true;
                            table.setData(allResults);
                            showAllLink.style.display = 'none';
                        }
                    }
                }
            ]
        };

        // Update indicator columns with proper sorting
        indicators.forEach(indicator => {
            tableConfig.columns.push({
                title: indicator.code,
                field: indicator.code,
                width: 160,
                sorter: "number",
                sortField: indicator.code + '_raw',
                headerSortStartingDir: "desc",
                formatter: function(cell) {
                    return formatNumber(cell.getValue(), formatType);
                },
                headerClick: function(e, column) {
                    if (!isShowingAllRows) {
                        isShowingAllRows = true;
                        table.setData(allResults);
                        showAllLink.style.display = 'none';
                    }
                }
            });
        });

        return new Tabulator("#table", tableConfig);
    }

      // Initialize table with simple format
      let table = initializeTable('simple');

      // Update format change listener
      const formatSelect = document.getElementById('number-format-select');
      formatSelect.addEventListener('change', function() {
        table.destroy();
        table = initializeTable(this.value);
        
        // Use isShowingAllRows to maintain state across format changes
        if (isShowingAllRows) {
            table.setData(allResults);
            showAllLink.style.display = 'none';
        } else {
            table.setData(sortedResults);
            showAllLink.style.display = 'block';
        }
      });

      // Update show all link handler
      const showAllLink = document.getElementById('showAllLink');
      showAllLink.addEventListener('click', function(e) {
        e.preventDefault();
        isShowingAllRows = true; // Set the state
        table.setData(allResults);
        this.style.display = 'none';
        
        setTimeout(() => {
          table.scrollToRow(table.getRows()[table.getRows().length - 1], "bottom", true);
        }, 100);
      });

      // Ensure link is visible initially unless showing all
      showAllLink.style.display = isShowingAllRows ? 'none' : 'block';
    }

    main();
  </script>
</body>
</html>