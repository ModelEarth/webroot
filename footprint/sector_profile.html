<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <title>Sector Analysis - Environmental profile</title>
  <link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link href="https://unpkg.com/tabulator-tables@5.2.7/dist/css/tabulator.min.css" rel="stylesheet">
  <script type="text/javascript" src="https://unpkg.com/tabulator-tables@5.2.7/dist/js/tabulator.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>

  <script type="text/javascript" src="/localsite/js/localsite.js?showheader=true&showsearch=true"></script>
  <script src="js/useeio.js"></script>
</head>

<body>

<div class="content contentpadding">
  <div style="margin-bottom: 10px; float:right"><select id="number-format-select"></select></div>
  <div style="margin-bottom: 10px; float:right"><select id="locale-select"></select></div>
  
  <div style="margin-bottom:10px">
    <a id="footprintLink" href="../state/" >US State Reports</a> - 
    <a id="commoditiesLink" href="commodities.html">Commodities</a>
  </div>
  <div id="relocatedStateMenu"></div>
  
  <p id="info">Loading ...</p>
  <div id="table" style="clear:both"></div>

  <!-- Heatmap visualization for the indicator table -->
  <div id="heatmapCard" style="display:none;margin-top:12px">
    <h3 style="margin:4px 0 6px">Direct vs Total Heatmap</h3>
    <div id="sectorHeatmap" style="height:420px;background:#fff;border-radius:8px;padding:0"></div>
  </div>
  
  <!-- Matrix and Data Sources Section -->
  <div id="matrixSection" style="margin-top: 40px; display: none;">
    <h3>Technical Coefficient Matrix</h3>
    <p id="matrixInfo">Loading matrix data...</p>
    <div id="matrixTable"></div>
    <div id="matrixTreemap" style="height:360px;background:#fff;border-radius:8px;padding:8px;margin-top:12px;display:none"></div>
    <div id="matrixTreemapTagline" style="font-size:13px;color:#444;margin-top:8px;display:none">Treemap: rectangles sized by absolute coefficient magnitude; color indicates normalized magnitude (low → high).</div>
  </div>
  
  <div id="dataSourcesSection" style="margin-top: 40px; display: none;">
    <h3>Data Sources</h3>
    <p id="dataSourcesInfo">Loading data sources...</p>
    <div id="dataSourcesTable"></div>
  </div><br><br>

  <div id="infoDiv"></div>

</div>

<script src="js/config.js"></script>
<script>
loadMarkdown("sector_profile_info.md", "infoDiv", "_parent");
document.addEventListener('hashChangeEvent', hashChangedUseeio, false);
function hashChangedUseeio() {
  console.log("URL hash changed");
  model = getModel();
  updateHash({"demand":""});
  main();
}

function norm100(nums) {
  let max = 0;
  for (const num of nums) {
    max = Math.max(Math.abs(num), max);
  }
  if (max === 0) {
    return nums;
  }
  const norm = [];
  for (const num of nums) {
    norm.push(100 * num / max)
  }
  return norm;
}

async function getRandomSector() {
  const sectors = await model.sectors();
  return sectors[Math.floor(Math.random() * sectors.length)];
}

async function main() {
  let hash = getHash();
  if (hash.state) {
    // Append to links at top of page.
    document.getElementById('footprintLink').setAttribute('href', '../state/#state=' + hash.state);
    document.getElementById('commoditiesLink').setAttribute('href', 'commodities.html#state=' + hash.state);
  }
  const info = document.getElementById("info");
  
  // Parse URL parameters
  //const fullhash = window.location.hash;
  //const params = new URLSearchParams(fullhash.substring(1));
  
  let sector;
  const sectors = await model.sectors();

  // loading random sector profile report if no hash
  if (!hash.demand) {
    sector = await getRandomSector();
    // update URL with random sector's hash
    // Only include location when it's a non-empty string (avoid appending booleans like 'true')
    const loc = (typeof sector.location === 'string' && sector.location) ? `/${sector.location}` : '';
    hash.demand = `${sector.code}${loc}`;
    updateHash({"demand":hash.demand});
  }
  
  // Handle demand parameter (new format)
  if (hash.demand) {
    const [code, location] = hash.demand.split("/");
    sector = sectors.find(s => s.code === code && s.location === location);
  }
  // Handle index parameter (legacy format)
  else if (hash.index) {
    const sectorIndex = parseInt(hash.index);
    sector = sectors.find(s => s.index === sectorIndex);
  }
  // Handle legacy industry parameter
  else if (hash.industry) {
    const sectorIndex = parseInt(hash.industry);
    sector = sectors.find(s => s.index === sectorIndex);
  }
  
  /*
  let stateCode;
  if (hash.state) {
    stateCode = hash.state;
  } else 

  if (hash.demand) {
    const [code, location] = hash.demand.split('/');
    if (!location) {
      info.textContent = "No location value in demand: " + hash.demand;
      document.getElementById('table').innerHTML = "";
      return;
    } else if (location.includes('/')) {
      stateCode = location.split('/')[1];
    }
  }
  */

  if (!sector) {
    info.textContent = "No valid sector specified in the URL.";
    if (hash.state) {
      info.textContent = `No valid sector specified in the URL in ${hash.state} model.`;
    }
    document.getElementById('table').innerHTML = "";
    return;
  }

  const demandId = await model.findDemand({
    system: "Complete",
    type: "Consumption",
  });
  if (!demandId) {
    info.textContent = "Failed to load demand";
    document.getElementById('table').innerHTML = "";
    return;
  }
  
  info.textContent = `Analyzing sector '${sector.name}' based on ${demandId}`;

  const analysis = await useeio.SectorAnalysis.of(model, sector, demandId);
  const indicators = await model.indicators();
  const direct = norm100(await analysis.getEnvironmentalProfile(true));
  const total = norm100(await analysis.getEnvironmentalProfile(false));
  // Get actual environmental values (not normalized)
  const directValues = await analysis.getEnvironmentalProfile(true);
  const totalValues = await analysis.getEnvironmentalProfile(false);
  
  tableData = indicators.map(i => {
    return {
      indicator: `${i.code} - ${i.name}`,
      direct: direct[i.index],
      total: total[i.index],
      directValue: directValues[i.index],
      totalValue: totalValues[i.index],
      directValueEasy: formatCell(directValues[i.index], 'easy'),
      totalValueEasy: formatCell(totalValues[i.index], 'easy'),
      unit: i.unit
    }
  });

  info.innerHTML = `<h3 style="font-size:22px">${sector.name}</h3><span style='float:right'>Amounts might be per dollar spent.</span>Environmental profile based on ${demandId} for <b>${sector.id}</b>`;
  
  // Now create the table using the displayTable function
  displayTable();

  // Load and display matrix and data sources
  await loadMatrixData(sector, analysis);
  await loadDataSources(sector);
}

async function loadMatrixData(sector, analysis) {
  try {
    const matrixSection = document.getElementById('matrixSection');
    const matrixInfo = document.getElementById('matrixInfo');
    const matrixTableDiv = document.getElementById('matrixTable');
    
    // Get model information for data source URL
    const modelName = getModelFolderName();
    const dataSourceUrl = `https://raw.githubusercontent.com/ModelEarth/useeio-json/main/models/2020/${modelName}/A.json`;
    
    matrixInfo.innerHTML = `Technical coefficients for sector: <strong>${sector.name}</strong><br>
      <small>Data source: <a href="${dataSourceUrl}" target="_blank">A Matrix (${modelName})</a></small>`;
    
    // Get matrix data from the model
    const sectors = await model.sectors();
    const matrixA = await model.matrix('A'); // Technical coefficient matrix
    
    console.log('Matrix A structure:', matrixA);
    console.log('Sector details:', sector);
    
    // Get matrix data using direct access like the working version
    let matrixData = [];
    
    if (matrixA && matrixA.data && matrixA.data.length > 0) {
      // Get the row for the current sector
      const sectorRow = matrixA.data[sector.index] || [];
      console.log('Sector row data (first 5):', sectorRow.slice(0, 5));
      
      // Create data for the top contributing sectors
      matrixData = sectors
        .map((s, index) => {
          // Ensure sector name is a usable string. Some models may have
          // non-string or boolean values in the name field; fall back to
          // the sector code or a generated label to avoid literal 'true'.
          const sectorNameSafe = (typeof s.name === 'string' && s.name.trim().length > 0)
            ? s.name.trim()
            : (typeof s.code === 'string' && s.code.trim().length > 0 ? s.code.trim() : `Sector ${index}`);
          return {
            sector: sectorNameSafe,
            coefficient: sectorRow[index] || 0,
            sectorCode: s.code,
            sectorId: s.id
          };
        })
        .filter(item => Math.abs(item.coefficient) > 0.0001) // Filter out very small values
        .sort((a, b) => Math.abs(b.coefficient) - Math.abs(a.coefficient))
        .slice(0, 25); // Show top 25 contributors
        
      console.log('Matrix data sample:', matrixData.slice(0, 3));
    }
    
    if (matrixData.length > 0) {
        // Create Tabulator table for matrix data
        matrixTable = new Tabulator("#matrixTable", {
          data: matrixData,
          layout: "fitColumns",
          width: "100%",
          columns: [
            { title: "Sector Name", field: "sector", widthGrow: 3 },
            { title: "Code", field: "sectorCode", width: 80 },
            { title: "Sector ID", field: "sectorId", width: 120 },
            { 
              title: "Coefficient", 
              field: "coefficient", 
              formatter: function(cell) {
                const val = cell.getValue();
                const formatType = getCurrentNumberFormat() || "simple";
                if (typeof formatCell === 'function') {
                  if (formatType === "simple") {
                    return formatCell(val, 'easy');
                  } else if (formatType === "full") {
                    return formatCell(val, 'full');
                  } else if (formatType === "scientific") {
                    return formatCell(val, 'scientific');
                  } else {
                    return formatCell(val, 'easy');
                  }
                } else {
                  // Fallback if formatCell is not available
                  return val.toExponential(4);
                }
              },
              sorter: "number",
              width: 150
            }
          ],
          initialSort: [
            { column: "coefficient", dir: "desc" }
          ]
        });
      // Render a treemap visualization of the matrix contributions
      try {
        renderMatrixTreemap(matrixData);
      } catch (e) { console.warn('renderMatrixTreemap failed', e); }
    } else {
      matrixTableDiv.innerHTML = '<p>No significant technical coefficients found for this sector.</p>';
    }
    
    matrixSection.style.display = 'block';
  } catch (error) {
    console.error('Error loading matrix data:', error);
    document.getElementById('matrixInfo').innerHTML = `Technical coefficients for sector: <strong>${sector.name}</strong><br><em>Error loading matrix data: ${error.message}</em>`;
    document.getElementById('matrixSection').style.display = 'block';
  }
}

function renderMatrixTreemap(matrixData) {
  try {
    const el = document.getElementById('matrixTreemap');
    const taglineEl = document.getElementById('matrixTreemapTagline');
    if (!el) return;
    if (!matrixData || matrixData.length === 0) {
      el.style.display = 'none';
      if (taglineEl) taglineEl.style.display = 'none';
      if (matrixTreemapChart) { try{ matrixTreemapChart.dispose(); }catch(e){} matrixTreemapChart=null; }
      return;
    }

    el.style.display = 'block';
    // Update tagline below treemap
    try {
      if (taglineEl) {
        const sectorName = (document.querySelector('#info h3') || {}).textContent || '';
        taglineEl.style.display = 'block';
        taglineEl.textContent = `${sectorName} — Treemap of top ${matrixData.length} contributing sectors: rectangle area = |coefficient|; color = normalized magnitude (low → high).`;
      }
    } catch (e) { /* ignore tagline errors */ }

    // Dispose previous chart if present
    if (matrixTreemapChart) { try { matrixTreemapChart.dispose(); } catch (e) { console.warn('dispose previous treemap failed', e); } matrixTreemapChart = null; }
    if (typeof echarts === 'undefined') { el.innerHTML = '<div style="color:#a00">ECharts not loaded</div>'; return; }
    const chart = echarts.init(el);
    matrixTreemapChart = chart;

    // Build nodes: each top contributor becomes a child node sized by abs(coefficient)
    const sizes = matrixData.map(d => Math.abs(d.coefficient || 0));
    const norm = norm100(sizes);
    const children = matrixData.map((d, i) => ({
      name: d.sector,
      value: sizes[i] || 0,
      coefficient: d.coefficient,
      sectorCode: d.sectorCode,
      sectorId: d.sectorId,
      // color by normalized magnitude
      itemStyle: { color: `hsl(${200 - Math.round((norm[i]||0) )}deg 65% ${Math.round(80 - (norm[i]||0)/1.5)}%)` }
    }));

    const option = {
      tooltip: {
        formatter: params => {
          const p = params.data || {};
          return `${p.name}<br/>Coefficient: ${formatCell(p.coefficient || 0, 'easy')}`;
        }
      },
      series: [{
        type: 'treemap',
        roam: false,
        nodeClick: false,
        breadcrumb: { show: false },
        label: { show: true, formatter: '{b}', ellipsis: true },
        data: [{ name: 'contributors', children: children }]
      }]
    };

    // Show loading and compute options asynchronously to avoid blocking the UI
    try { chart.showLoading(); } catch (e) {}
    // remove previous resize handler if present
    try { if (matrixTreemapResizeHandler) { window.removeEventListener('resize', matrixTreemapResizeHandler); matrixTreemapResizeHandler = null; } } catch (e) {}
    setTimeout(() => {
      try {
  chart.setOption(option);
  try { chart.hideLoading(); } catch (e) {}
  // Force a few resize/paint cycles so layout completes even when
  // DevTools isn't open (some browsers delay layout otherwise).
  try { matrixTreemapChart.resize(); } catch (e) {}
  try { requestAnimationFrame(() => { try { matrixTreemapChart.resize(); } catch (e) {} }); } catch (e) {}
  try { setTimeout(() => { try { matrixTreemapChart.resize(); } catch (e) {} }, 200); } catch (e) {}
  // attach a single resize handler for the treemap
  matrixTreemapResizeHandler = () => { try { if (matrixTreemapChart) matrixTreemapChart.resize(); } catch (e) {} };
  window.addEventListener('resize', matrixTreemapResizeHandler);
      } catch (err) {
        console.error('treemap setOption failed', err);
        try { chart.hideLoading(); } catch (e) {}
      }
    }, 20);
  } catch (e) { console.error('renderMatrixTreemap failed', e); }
}

async function loadDataSources(sector) {
  try {
    const dataSourcesSection = document.getElementById('dataSourcesSection');
    const dataSourcesInfo = document.getElementById('dataSourcesInfo');
    const dataSourcesTable = document.getElementById('dataSourcesTable');
    
    // Get model information
    const modelName = getModelFolderName();
    //const baseUrlRaw = `https://raw.githubusercontent.com/ModelEarth/useeio-json/main/models/2020/${modelName}`;
    const baseUrl = `https://github.com/ModelEarth/useeio-json/blob/main/models/2020/${modelName}`;
    
    dataSourcesInfo.innerHTML = `Data sources and methodology for sector: <strong>${sector.name}</strong> (${modelName})`;
    
    // Get model metadata
    let metadata;
    try {
      metadata = await model.metadata();
    } catch (e) {
      console.warn('Could not load metadata:', e);
      metadata = { version: modelName };
    }
    
    // Get indicators and demands to show what data is actually used
    const indicators = await model.indicators();
    const demands = await model.demands();
    
    // Create comprehensive data sources information
    const dataSourcesData = [
      {
        dataset: "Technical Coefficient Matrix (A)",
        description: "Inter-industry economic relationships and dependencies",
        format: "JSON Matrix",
        url: `${baseUrl}/matrix/A.json`,
        usage: "Calculates direct economic impacts between sectors"
      },
      {
        dataset: "Environmental Matrix (B)",
        description: "Direct environmental coefficients by sector",
        format: "JSON Matrix", 
        url: `${baseUrl}/matrix/B.json`,
        usage: "Direct environmental impacts per dollar of output"
      },
      {
        dataset: "Total Requirements Matrix (L)",
        description: "Leontief inverse matrix (I-A)^-1",
        format: "JSON Matrix",
        url: `${baseUrl}/matrix/L.json`, 
        usage: "Calculates total economic requirements (direct + indirect)"
      },
      {
        dataset: "Environmental Multipliers (D)",
        description: "Total environmental impact coefficients",
        format: "JSON Matrix",
        url: `${baseUrl}/matrix/D.json`,
        usage: "Total environmental impacts (direct + indirect + induced)"
      },
      {
        dataset: "Sectors",
        description: `${sector.code} - ${sector.name} and all other sectors`,
        format: "JSON Array",
        url: `${baseUrl}/sectors.json`,
        usage: "Sector classification and naming"
      },
      {
        dataset: "Indicators", 
        description: `${indicators.length} environmental impact indicators`,
        format: "JSON Array",
        url: `${baseUrl}/indicators.json`,
        usage: "Environmental impact categories (GHG, water, land, etc.)"
      },
      {
        dataset: "Demands",
        description: `${demands.length} demand vectors available`,
        format: "JSON Object",
        url: `${baseUrl}/demands.json`, 
        usage: "Economic demand scenarios for analysis"
      }
    ];
    
    // Add location-specific information if available
    if (sector.location && sector.location !== 'US') {
      dataSourcesData.push({
        dataset: "State-Level Data",
        description: `Location-specific data for ${sector.location}`,
        format: "Model Extension",
        url: "https://www.epa.gov/land-research/useeio-state-models",
        usage: "State-level economic and environmental coefficients"
      });
    }
    
    // Add metadata information
    dataSourcesData.push({
      dataset: "Model Metadata",
      description: `${metadata?.name || modelName} model information`,
      format: "JSON Object", 
      url: `${baseUrl}/metadata.json`,
      usage: "Model version, description, and technical specifications"
    });
    
    // Create Tabulator table for data sources
    new Tabulator("#dataSourcesTable", {
      data: dataSourcesData,
      layout: "fitColumns",
      width: "100%",
      columns: [
        { title: "Dataset", field: "dataset", width: 180 },
        { title: "Description", field: "description", widthGrow: 2 },
        { title: "Usage in Report", field: "usage", widthGrow: 2 },
        { title: "Format", field: "format", width: 100 },
        { 
          title: "Data Link", 
          field: "url", 
          formatter: function(cell) {
            const url = cell.getValue();
            const filename = url.split('/').pop();
            return `<a href="${url}" target="_blank">${filename}</a>`;
          },
          width: 120
        }
      ]
    });
    
    dataSourcesSection.style.display = 'block';
  } catch (error) {
    console.error('Error loading data sources:', error);
    document.getElementById('dataSourcesInfo').innerHTML = `Data sources and methodology for sector: <strong>${sector?.name || 'Unknown'}</strong><br><em>Error: ${error.message}</em>`;
    document.getElementById('dataSourcesSection').style.display = 'block';
  }
}

// Store table references for updating
var mainTable, matrixTable;

// Keep a global reference to the matrix treemap chart so we can dispose/resize reliably
let matrixTreemapChart = null;
// Keep a reference to the resize handler so we don't add many listeners
let matrixTreemapResizeHandler = null;

// Global variable to store results data
let tableData = [];
// Keep a global reference to the heatmap chart so we can dispose/resize reliably
let sectorHeatmapChart = null;

function displayTable() {
  const formatType = getCurrentNumberFormat() || "simple";
  
  const columns = [
    { title: "Indicator", field: "indicator", widthGrow: 2 },
    { title: "Direct", field: "direct", formatter: "progress", sorter: "number", headerSortTristate: false, headerSortStartingDir: "desc", minWidth: 160 },
    { title: "Total", field: "total", formatter: "progress", sorter: "number", minWidth: 160 },
    {
      title: "Direct",
      field: formatType === "simple" ? "directValueEasy" : "directValue",
      sorter: formatType === "simple" ? function(a, b, aRow, bRow) {
        return aRow.getData().directValue - bRow.getData().directValue;
      } : "number",
      formatter: function(cell) {
        const val = cell.getValue();
        if (formatType === "simple") {
          return val; // Already formatted by formatCell
        } else if (formatType === "full") {
          return formatCell(val, 'full');
        } else if (formatType === "scientific") {
          let scientificValue = Number(val).toExponential(3);
          let parts = scientificValue.split("e");
          let base = parts[0];
          let exponent = parts[1];
          if (exponent) {
            return `${base}&times;10<sup>${exponent.replace('+', '')}</sup>`;
          }
          return scientificValue;
        }
        return val;
      },
      width: 120
    },
    {
      title: "Total",
      field: formatType === "simple" ? "totalValueEasy" : "totalValue",
      sorter: formatType === "simple" ? function(a, b, aRow, bRow) {
        return aRow.getData().totalValue - bRow.getData().totalValue;
      } : "number",
      formatter: function(cell) {
        const val = cell.getValue();
        if (formatType === "simple") {
          return val; // Already formatted by formatCell
        } else if (formatType === "full") {
          return formatCell(val, 'full');
        } else if (formatType === "scientific") {
          let scientificValue = Number(val).toExponential(3);
          let parts = scientificValue.split("e");
          let base = parts[0];
          let exponent = parts[1];
          if (exponent) {
            return `${base}&times;10<sup>${exponent.replace('+', '')}</sup>`;
          }
          return scientificValue;
        }
        return val;
      },
      width: 120
    },
    { title: "Unit", field: "unit", width: 100 }
  ];

  renderHeatmap();

  mainTable = new Tabulator("#table", {
    data: tableData,
    layout: "fitColumns",
    width: "100%",
    columns: columns,
    initialSort: [
      { column: "total", dir: "desc" },
    ]
  });

  // After table is created, render the heatmap based on the table data
  
}

function renderHeatmap() {
  try {
    console.debug('renderHeatmap: tableData length=', (tableData && tableData.length));
    console.debug('renderHeatmap: tableData sample=', (tableData && tableData.slice(0,3)));
    const heatCard = document.getElementById('heatmapCard');
    const el = document.getElementById('sectorHeatmap');
    if (!tableData || tableData.length === 0) {
      heatCard.style.display = 'none';
      // dispose any existing chart
      if (sectorHeatmapChart) { try { sectorHeatmapChart.dispose(); } catch(e){}; sectorHeatmapChart = null; }
      return;
    }
    heatCard.style.display = 'block';
    // Move the heatmap card above the main table so the heatmap is shown on top
    try {
      const tableDiv = document.getElementById('table');
      if (tableDiv && heatCard.parentNode !== tableDiv.parentNode) {
        tableDiv.parentNode.insertBefore(heatCard, tableDiv);
      } else if (tableDiv && heatCard.compareDocumentPosition(tableDiv) & Node.DOCUMENT_POSITION_FOLLOWING) {
        // already before
      } else if (tableDiv) {
        // ensure inserted before table
        tableDiv.parentNode.insertBefore(heatCard, tableDiv);
      }
    } catch (e) { console.warn('Could not move heatmap above table', e); }
    if (typeof echarts === 'undefined') {
      el.innerHTML = '<div style="color:#a00">ECharts not loaded</div>';
      return;
    }
    // dispose previous instance if present
    if (sectorHeatmapChart) {
      try { sectorHeatmapChart.dispose(); } catch (e) { console.warn('dispose previous heatmap failed', e); }
      sectorHeatmapChart = null;
    }
    const chart = echarts.init(el);
    sectorHeatmapChart = chart;

    // Use the current tableData (which contains indicator, direct, total, unit, directValue, totalValue)
    // Preserve both normalized numeric values (direct/total) used for coloring
    // and the preformatted "easy" display strings used by the table so tooltips
    // and hover labels can show the same human-friendly values.
    const rows = tableData.map(r => ({
      indicator: r.indicator,
      direct: Number(r.direct) || 0,
      total: Number(r.total) || 0,
      unit: r.unit,
      rawDirect: r.directValue,
      rawTotal: r.totalValue,
      directEasy: r.directValueEasy, // already formatted by formatCell(...,'easy')
      totalEasy: r.totalValueEasy
    }));
  // y-axis should show a short label (first 4 letters of the indicator name)
    // but keep the full indicator string in rows for tooltips.
    const labels = rows.map(r => {
      // indicator is usually formatted as "CODE - Name". Try to extract the name
      const parts = (r.indicator || '').split(' - ');
      const namePart = parts.length > 1 ? parts.slice(0).join(' - ').trim() : (parts[0] || '');
      return namePart.substring(0, 4);
    });

    // Adjust the heatmap container height so that each indicator row has
    // enough vertical space. This makes labels readable and avoids clipping.
    // Use a per-row pixel height and add padding; cap the height to avoid
    // excessively tall charts and fall back to scroll when necessary.
    try {
      const minHeight =400;
  const rowHeight = 60; // pixels per indicator row (increased for better readability)
      const padding = 70; // header/legend/padding
      const maxHeight = 500; // cap to keep page usable
      const desiredHeight = Math.max(minHeight, labels.length * rowHeight + padding);
      const finalHeight = Math.min(desiredHeight, maxHeight);
      // set height on the chart container
      el.style.height = finalHeight + 'px';
      // enable scrolling on the card if we hit the cap
      const heatCard = document.getElementById('heatmapCard');
      if (desiredHeight > maxHeight && heatCard) {
        heatCard.style.overflowY = 'auto';
      } else if (heatCard) {
        heatCard.style.overflowY = '';
      }
    } catch (e) {
      // ignore layout errors
      console.warn('Failed to adjust heatmap height', e);
    }

    // Build heatmap data: two columns (Direct, Total)
    // Assign a consistent hue per unit and shade by the normalized value so
    // indicators with the same unit look related.
    const units = Array.from(new Set(rows.map(r => r.unit || '').filter(u => u !== ''))).sort();
    const unitHue = {};
    units.forEach((u, idx) => { unitHue[u] = Math.round((idx * 360) / Math.max(1, units.length)); });
    function colorFor(unit, normVal) {
      // normVal expected 0..100. Map to lightness 92% (low) -> 36% (high).
      const h = unitHue[unit] || 200; // fallback hue
      const light = Math.round(92 - (normVal / 100) * 56);
      return `hsl(${h}deg 65% ${light}%)`;
    }

    const data = [];
    rows.forEach((r, i) => {
      data.push({ value: [0, i, r.direct], itemStyle: { color: colorFor(r.unit, r.direct) }, unit: r.unit });
      data.push({ value: [1, i, r.total], itemStyle: { color: colorFor(r.unit, r.total) }, unit: r.unit });
    });

    // Build a small unit legend (gradient swatches) under the heatmap
    // Each swatch is a gradient from colorFor(unit,0) -> colorFor(unit,100)
    try {
      const legend = document.getElementById('unitLegend') || (() => {
        const n = document.createElement('div'); n.id = 'unitLegend'; n.style.marginTop = '8px'; n.style.display = 'flex'; n.style.gap = '12px'; n.style.flexWrap = 'wrap'; n.style.alignItems = 'center';
        const card = document.getElementById('heatmapCard'); if (card) card.appendChild(n);
        return n;
      })();
      legend.innerHTML = '';
      units.forEach(u => {
        const sw = document.createElement('div');
        sw.style.display = 'flex'; sw.style.alignItems = 'center'; sw.style.gap = '6px';
        const box = document.createElement('div');
        box.style.width = '60px'; box.style.height = '14px'; box.style.borderRadius = '4px'; box.style.marginRight = '6px';
        // Use an exact left->right gradient that matches the cell color mapping
        const left = colorFor(u, 0);
        const right = colorFor(u, 100);
        box.style.background = `linear-gradient(90deg, ${left}, ${right})`;
        box.style.border = '1px solid rgba(0,0,0,0.08)';
        box.title = `${u || '(no unit)'} — low → high`;
        const lbl = document.createElement('div'); lbl.style.fontSize = '12px'; lbl.style.whiteSpace = 'nowrap'; lbl.textContent = u || '(no unit)';
        sw.appendChild(box); sw.appendChild(lbl); legend.appendChild(sw);
      });
      // Add explanatory note for legend if not already present
      if (!legend.dataset.note) {
        const note = document.createElement('div'); note.style.fontSize = '11px'; note.style.color = '#444'; note.style.marginLeft = '8px'; note.textContent = 'Legend: gradient shows unit color mapping (low → high)';
        legend.appendChild(note);
        legend.dataset.note = '1';
      }
    } catch (e) { console.warn('unit legend build failed', e); }

    const option = {
      tooltip: { position: 'top', formatter: params => {
        const p = Array.isArray(params) ? params[0] : params;
        const valArr = p.data && p.data.value ? p.data.value : p.data;
        const colIdx = valArr[0];
        const rowIdx = valArr[1];
        const col = colIdx === 0 ? 'Direct' : 'Total';
        const row = rows[rowIdx];
        const easy = colIdx === 0 ? row.directEasy : row.totalEasy;
        return `${row.indicator}<br/>${col}: ${easy} ${row.unit || ''}`;
      }},
  // Use tighter grid bounds and containLabel to remove unnecessary whitespace
  // Increase top margin so there is room when the visualMap (scale) is placed above
  grid: { top: 96, bottom: 12, left: 80, right: 16, containLabel: true },
  xAxis: { type: 'category', data: ['Direct','Total'] },
  yAxis: { type: 'category', data: labels, inverse: true },
  // NOTE: visualMap removed so the built-in scale doesn't show a palette
  // The unit-specific legend below the chart shows gradients that exactly
  // match the colors used for cells (colorFor(unit,0) -> colorFor(unit,100)).
      series: [{
        name: 'Direct vs Total',
        type: 'heatmap',
        data: data,
        label: { show: false },
        emphasis: {
          itemStyle: { borderColor: '#000', borderWidth: 1 },
          label: {
            show: true,
            // Show the same easy formatted value on hover (emphasis)
            formatter: params => {
              const valArr = params.data && params.data.value ? params.data.value : params.data;
              const colIdx = valArr[0];
              const rowIdx = valArr[1];
              const row = rows[rowIdx] || {};
              return colIdx === 0 ? (row.directEasy + (row.unit ? ' ' + row.unit : '')) : (row.totalEasy + (row.unit ? ' ' + row.unit : ''));
            }
          }
        }
      }]
    };

    chart.setOption(option);
    window.addEventListener('resize', ()=>{ try{ if (sectorHeatmapChart) sectorHeatmapChart.resize(); }catch(e){} });
  } catch (e) { console.error('renderHeatmap failed', e); }
}

// Initialize dropdowns and add event listeners
function initializeDropdownsAndEvents() {
  console.log('Initializing dropdowns and events');
  
  // Check if dropdown elements exist
  const localeSelect = document.getElementById('locale-select');
  const numberFormatSelect = document.getElementById('number-format-select');
  console.log('Locale select found:', !!localeSelect);
  console.log('Number format select found:', !!numberFormatSelect);
  
  // Initialize the dropdowns
  if (typeof initializeDropdowns === 'function') {
    initializeDropdowns();
    console.log('Dropdowns initialized');
  } else {
    console.error('initializeDropdowns function not available from config.js');
  }
  
  // Add event listeners to update tables when dropdowns change
  if (localeSelect) {
    localeSelect.addEventListener("change", function() {
      updateTables();
    });
  }
  
  if (numberFormatSelect) {
    numberFormatSelect.addEventListener("change", function() {
      updateTables();
    });
  }
}

// Function to update all tables when format changes
function updateTables() {
  // Recreate the main table with new format (like commodities.html)
  if (tableData && tableData.length > 0) {
    displayTable();
  }
  // For matrix table, just redraw since it uses dynamic formatters
  if (matrixTable) {
    matrixTable.redraw();
  }
}

// Initialize everything when page loads
window.addEventListener('load', function() {
  // Give a small delay to ensure all scripts are loaded
  setTimeout(function() {
    initializeDropdownsAndEvents();
  }, 100);
});

main();
</script>

</body>
</html>