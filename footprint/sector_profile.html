<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <title>Sector Analysis - Environmental profile</title>
  <link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link href="https://unpkg.com/tabulator-tables@5.2.7/dist/css/tabulator.min.css" rel="stylesheet">
  <script type="text/javascript" src="https://unpkg.com/tabulator-tables@5.2.7/dist/js/tabulator.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>

  <script type="text/javascript" src="/localsite/js/localsite.js?showheader=true&showsearch=true"></script>
  <script src="js/useeio.js"></script>
</head>

<body>

<div class="content contentpadding">
  <div style="margin-bottom: 10px; float:right"><select id="number-format-select"></select></div>
  <div style="margin-bottom: 10px; float:right"><select id="locale-select"></select></div>
  <div style="margin-bottom: 10px; float:right; margin-right:8px">
    <label style="font-size:13px;white-space:nowrap">Show: <select id="impact-filter-select"><option value="negative" selected>Negative Impacts</option><option value="positive">Positive Impacts</option><option value="all">All Impacts</option></select></label>
  </div>
  
  <div style="margin-bottom:10px">
    <a id="footprintLink" href="../state/" >US State Reports</a> - 
    <a id="commoditiesLink" href="commodities.html">Commodities</a>
  </div>
  <div id="relocatedStateMenu"></div>
  
  <p id="info">Loading ...</p>
  <div id="table" style="clear:both"></div>

  <!-- Heatmap removed -->
  
  <!-- Matrix and Data Sources Section -->
  <div id="matrixSection" style="margin-top: 40px; display: none;">
    <h3>Technical Coefficient Matrix</h3>
    <p id="matrixInfo">Loading matrix data...</p>
    <div id="matrixTable"></div>
    <div id="matrixTreemap" style="height:360px;background:#fff;border-radius:8px;padding:8px;margin-top:12px;display:none"></div>
    <div id="matrixTreemapTagline" style="font-size:13px;color:#444;margin-top:8px;display:none">Treemap: rectangles sized by absolute coefficient magnitude; color indicates normalized magnitude (low → high).</div>
  </div>
  
  <div id="dataSourcesSection" style="margin-top: 40px; display: none;">
    <h3>Data Sources</h3>
    <p id="dataSourcesInfo">Loading data sources...</p>
    <div id="dataSourcesTable"></div>
  </div><br><br>

  <div id="infoDiv"></div>

</div>

<script src="js/config.js"></script>
<script>
loadMarkdown("sector_profile_info.md", "infoDiv", "_parent");
document.addEventListener('hashChangeEvent', hashChangedUseeio, false);
function hashChangedUseeio() {
  console.log("URL hash changed");
  model = getModel();
  updateHash({"demand":""});
  main();
}

function norm100(nums) {
  let max = 0;
  for (const num of nums) {
    max = Math.max(Math.abs(num), max);
  }
  if (max === 0) {
    return nums;
  }
  const norm = [];
  for (const num of nums) {
    norm.push(100 * num / max)
  }
  return norm;
}

async function getRandomSector() {
  const sectors = await model.sectors();
  return sectors[Math.floor(Math.random() * sectors.length)];
}

async function main() {
  let hash = getHash();
  if (hash.state) {
    // Append to links at top of page.
    document.getElementById('footprintLink').setAttribute('href', '../state/#state=' + hash.state);
    document.getElementById('commoditiesLink').setAttribute('href', 'commodities.html#state=' + hash.state);
  }
  const info = document.getElementById("info");
  
  // Parse URL parameters
  //const fullhash = window.location.hash;
  //const params = new URLSearchParams(fullhash.substring(1));
  
  let sector;
  const sectors = await model.sectors();

  // loading random sector profile report if no hash
  if (!hash.demand) {
    sector = await getRandomSector();
    // update URL with random sector's hash
    // Only include location when it's a non-empty string (avoid appending booleans like 'true')
    const loc = (typeof sector.location === 'string' && sector.location) ? `/${sector.location}` : '';
    hash.demand = `${sector.code}${loc}`;
    updateHash({"demand":hash.demand});
  }
  
  // Handle demand parameter (new format)
  if (hash.demand) {
    const [code, location] = hash.demand.split("/");
    sector = sectors.find(s => s.code === code && s.location === location);
  }
  // Handle index parameter (legacy format)
  else if (hash.index) {
    const sectorIndex = parseInt(hash.index);
    sector = sectors.find(s => s.index === sectorIndex);
  }
  // Handle legacy industry parameter
  else if (hash.industry) {
    const sectorIndex = parseInt(hash.industry);
    sector = sectors.find(s => s.index === sectorIndex);
  }
  
  /*
  let stateCode;
  if (hash.state) {
    stateCode = hash.state;
  } else 

  if (hash.demand) {
    const [code, location] = hash.demand.split('/');
    if (!location) {
      info.textContent = "No location value in demand: " + hash.demand;
      document.getElementById('table').innerHTML = "";
      return;
    } else if (location.includes('/')) {
      stateCode = location.split('/')[1];
    }
  }
  */

  if (!sector) {
    info.textContent = "No valid sector specified in the URL.";
    if (hash.state) {
      info.textContent = `No valid sector specified in the URL in ${hash.state} model.`;
    }
    document.getElementById('table').innerHTML = "";
    return;
  }

  const demandId = await model.findDemand({
    system: "Complete",
    type: "Consumption",
  });
  if (!demandId) {
    info.textContent = "Failed to load demand";
    document.getElementById('table').innerHTML = "";
    return;
  }
  
  info.textContent = `Analyzing sector '${sector.name}' based on ${demandId}`;

  const analysis = await useeio.SectorAnalysis.of(model, sector, demandId);
  const indicators = await model.indicators();
  const direct = norm100(await analysis.getEnvironmentalProfile(true));
  const total = norm100(await analysis.getEnvironmentalProfile(false));
  // Get actual environmental values (not normalized)
  const directValues = await analysis.getEnvironmentalProfile(true);
  const totalValues = await analysis.getEnvironmentalProfile(false);
  
  fullTableData = indicators.map(i => {
    return {
      indicator: `${i.code} - ${i.name}`,
      direct: direct[i.index],
      total: total[i.index],
      directValue: directValues[i.index],
      totalValue: totalValues[i.index],
      directValueEasy: formatCell(directValues[i.index], 'easy'),
      totalValueEasy: formatCell(totalValues[i.index], 'easy'),
      unit: i.unit
    }
  });

  info.innerHTML = `<h3 style="font-size:22px">${sector.name}</h3><span style='float:right'>Amounts might be per dollar spent.</span>Environmental profile based on ${demandId} for <b>${sector.id}</b>`;
  
  // Filter according to the selected impact filter and create the table
  filterTableData();
  displayTable();

  // Load and display matrix and data sources
  await loadMatrixData(sector, analysis);
  await loadDataSources(sector);
}

async function loadMatrixData(sector, analysis) {
  try {
    const matrixSection = document.getElementById('matrixSection');
    const matrixInfo = document.getElementById('matrixInfo');
    const matrixTableDiv = document.getElementById('matrixTable');
    
    // Get model information for data source URL
    const modelName = getModelFolderName();
    const dataSourceUrl = `https://raw.githubusercontent.com/ModelEarth/useeio-json/main/models/2020/${modelName}/A.json`;
    
    matrixInfo.innerHTML = `Technical coefficients for sector: <strong>${sector.name}</strong><br>
      <small>Data source: <a href="${dataSourceUrl}" target="_blank">A Matrix (${modelName})</a></small>`;
    
    // Get matrix data from the model
    const sectors = await model.sectors();
    const matrixA = await model.matrix('A'); // Technical coefficient matrix
    
    console.log('Matrix A structure:', matrixA);
    console.log('Sector details:', sector);
    
    // Get matrix data using direct access like the working version
    let matrixData = [];
    
    if (matrixA && matrixA.data && matrixA.data.length > 0) {
      // Get the row for the current sector
      const sectorRow = matrixA.data[sector.index] || [];
      console.log('Sector row data (first 5):', sectorRow.slice(0, 5));
      
      // Create data for the top contributing sectors
      matrixData = sectors
        .map((s, index) => {
          // Ensure sector name is a usable string. Some models may have
          // non-string or boolean values in the name field; fall back to
          // the sector code or a generated label to avoid literal 'true'.
          const sectorNameSafe = (typeof s.name === 'string' && s.name.trim().length > 0)
            ? s.name.trim()
            : (typeof s.code === 'string' && s.code.trim().length > 0 ? s.code.trim() : `Sector ${index}`);
          return {
            sector: sectorNameSafe,
            coefficient: sectorRow[index] || 0,
            sectorCode: s.code,
            sectorId: s.id
          };
        })
        .filter(item => Math.abs(item.coefficient) > 0.0001) // Filter out very small values
        .sort((a, b) => Math.abs(b.coefficient) - Math.abs(a.coefficient))
        .slice(0, 25); // Show top 25 contributors
        
      console.log('Matrix data sample:', matrixData.slice(0, 3));
    }
    
    if (matrixData.length > 0) {
        // Create Tabulator table for matrix data
        matrixTable = new Tabulator("#matrixTable", {
          data: matrixData,
          layout: "fitColumns",
          width: "100%",
          columns: [
            { title: "Sector Name", field: "sector", widthGrow: 3 },
            { title: "Code", field: "sectorCode", width: 80 },
            { title: "Sector ID", field: "sectorId", width: 120 },
            { 
              title: "Coefficient", 
              field: "coefficient", 
              formatter: function(cell) {
                const val = cell.getValue();
                const formatType = getCurrentNumberFormat() || "simple";
                if (typeof formatCell === 'function') {
                  if (formatType === "simple") {
                    return formatCell(val, 'easy');
                  } else if (formatType === "full") {
                    return formatCell(val, 'full');
                  } else if (formatType === "scientific") {
                    return formatCell(val, 'scientific');
                  } else {
                    return formatCell(val, 'easy');
                  }
                } else {
                  // Fallback if formatCell is not available
                  return val.toExponential(4);
                }
              },
              sorter: "number",
              width: 150
            }
          ],
          initialSort: [
            { column: "coefficient", dir: "desc" }
          ]
        });
      // Render a treemap visualization of the matrix contributions
      try {
        renderMatrixTreemap(matrixData);
      } catch (e) { console.warn('renderMatrixTreemap failed', e); }
    } else {
      matrixTableDiv.innerHTML = '<p>No significant technical coefficients found for this sector.</p>';
    }
    
    matrixSection.style.display = 'block';
  } catch (error) {
    console.error('Error loading matrix data:', error);
    document.getElementById('matrixInfo').innerHTML = `Technical coefficients for sector: <strong>${sector.name}</strong><br><em>Error loading matrix data: ${error.message}</em>`;
    document.getElementById('matrixSection').style.display = 'block';
  }
}

function renderMatrixTreemap(matrixData) {
  try {
    const el = document.getElementById('matrixTreemap');
    const taglineEl = document.getElementById('matrixTreemapTagline');
    if (!el) return;
    if (!matrixData || matrixData.length === 0) {
      el.style.display = 'none';
      if (taglineEl) taglineEl.style.display = 'none';
      if (matrixTreemapChart) { try{ matrixTreemapChart.dispose(); }catch(e){} matrixTreemapChart=null; }
      return;
    }

    el.style.display = 'block';
    // Update tagline below treemap
    try {
      if (taglineEl) {
        const sectorName = (document.querySelector('#info h3') || {}).textContent || '';
        taglineEl.style.display = 'block';
        taglineEl.textContent = `${sectorName} — Treemap of top ${matrixData.length} contributing sectors: rectangle area = |coefficient|; color = normalized magnitude (low → high).`;
      }
    } catch (e) { /* ignore tagline errors */ }

    // Dispose previous chart if present
    if (matrixTreemapChart) { try { matrixTreemapChart.dispose(); } catch (e) { console.warn('dispose previous treemap failed', e); } matrixTreemapChart = null; }
    if (typeof echarts === 'undefined') { el.innerHTML = '<div style="color:#a00">ECharts not loaded</div>'; return; }
    const chart = echarts.init(el);
    matrixTreemapChart = chart;

    // Build nodes: each top contributor becomes a child node sized by abs(coefficient)
    const sizes = matrixData.map(d => Math.abs(d.coefficient || 0));
    const norm = norm100(sizes);
    const children = matrixData.map((d, i) => ({
      name: d.sector,
      value: sizes[i] || 0,
      coefficient: d.coefficient,
      sectorCode: d.sectorCode,
      sectorId: d.sectorId,
      // color by normalized magnitude
      itemStyle: { color: `hsl(${200 - Math.round((norm[i]||0) )}deg 65% ${Math.round(80 - (norm[i]||0)/1.5)}%)` }
    }));

    const option = {
      tooltip: {
        formatter: params => {
          const p = params.data || {};
          return `${p.name}<br/>Coefficient: ${formatCell(p.coefficient || 0, 'easy')}`;
        }
      },
      series: [{
        type: 'treemap',
        roam: false,
        nodeClick: false,
        breadcrumb: { show: false },
        label: { show: true, formatter: '{b}', ellipsis: true },
        data: [{ name: 'contributors', children: children }]
      }]
    };

    // Show loading and compute options asynchronously to avoid blocking the UI
    try { chart.showLoading(); } catch (e) {}
    // remove previous resize handler if present
    try { if (matrixTreemapResizeHandler) { window.removeEventListener('resize', matrixTreemapResizeHandler); matrixTreemapResizeHandler = null; } } catch (e) {}
    setTimeout(() => {
      try {
  chart.setOption(option);
  try { chart.hideLoading(); } catch (e) {}
  // Force a few resize/paint cycles so layout completes even when
  // DevTools isn't open (some browsers delay layout otherwise).
  try { matrixTreemapChart.resize(); } catch (e) {}
  try { requestAnimationFrame(() => { try { matrixTreemapChart.resize(); } catch (e) {} }); } catch (e) {}
  try { setTimeout(() => { try { matrixTreemapChart.resize(); } catch (e) {} }, 200); } catch (e) {}
  // attach a single resize handler for the treemap
  matrixTreemapResizeHandler = () => { try { if (matrixTreemapChart) matrixTreemapChart.resize(); } catch (e) {} };
  window.addEventListener('resize', matrixTreemapResizeHandler);
      } catch (err) {
        console.error('treemap setOption failed', err);
        try { chart.hideLoading(); } catch (e) {}
      }
    }, 20);
  } catch (e) { console.error('renderMatrixTreemap failed', e); }
}

async function loadDataSources(sector) {
  try {
    const dataSourcesSection = document.getElementById('dataSourcesSection');
    const dataSourcesInfo = document.getElementById('dataSourcesInfo');
    const dataSourcesTable = document.getElementById('dataSourcesTable');
    
    // Get model information
    const modelName = getModelFolderName();
    //const baseUrlRaw = `https://raw.githubusercontent.com/ModelEarth/useeio-json/main/models/2020/${modelName}`;
    const baseUrl = `https://github.com/ModelEarth/useeio-json/blob/main/models/2020/${modelName}`;
    
    dataSourcesInfo.innerHTML = `Data sources and methodology for sector: <strong>${sector.name}</strong> (${modelName})`;
    
    // Get model metadata
    let metadata;
    try {
      metadata = await model.metadata();
    } catch (e) {
      console.warn('Could not load metadata:', e);
      metadata = { version: modelName };
    }
    
    // Get indicators and demands to show what data is actually used
    const indicators = await model.indicators();
    const demands = await model.demands();
    
    // Create comprehensive data sources information
    const dataSourcesData = [
      {
        dataset: "Technical Coefficient Matrix (A)",
        description: "Inter-industry economic relationships and dependencies",
        format: "JSON Matrix",
        url: `${baseUrl}/matrix/A.json`,
        usage: "Calculates direct economic impacts between sectors"
      },
      {
        dataset: "Environmental Matrix (B)",
        description: "Direct environmental coefficients by sector",
        format: "JSON Matrix", 
        url: `${baseUrl}/matrix/B.json`,
        usage: "Direct environmental impacts per dollar of output"
      },
      {
        dataset: "Total Requirements Matrix (L)",
        description: "Leontief inverse matrix (I-A)^-1",
        format: "JSON Matrix",
        url: `${baseUrl}/matrix/L.json`, 
        usage: "Calculates total economic requirements (direct + indirect)"
      },
      {
        dataset: "Environmental Multipliers (D)",
        description: "Total environmental impact coefficients",
        format: "JSON Matrix",
        url: `${baseUrl}/matrix/D.json`,
        usage: "Total environmental impacts (direct + indirect + induced)"
      },
      {
        dataset: "Sectors",
        description: `${sector.code} - ${sector.name} and all other sectors`,
        format: "JSON Array",
        url: `${baseUrl}/sectors.json`,
        usage: "Sector classification and naming"
      },
      {
        dataset: "Indicators", 
        description: `${indicators.length} environmental impact indicators`,
        format: "JSON Array",
        url: `${baseUrl}/indicators.json`,
        usage: "Environmental impact categories (GHG, water, land, etc.)"
      },
      {
        dataset: "Demands",
        description: `${demands.length} demand vectors available`,
        format: "JSON Object",
        url: `${baseUrl}/demands.json`, 
        usage: "Economic demand scenarios for analysis"
      }
    ];
    
    // Add location-specific information if available
    if (sector.location && sector.location !== 'US') {
      dataSourcesData.push({
        dataset: "State-Level Data",
        description: `Location-specific data for ${sector.location}`,
        format: "Model Extension",
        url: "https://www.epa.gov/land-research/useeio-state-models",
        usage: "State-level economic and environmental coefficients"
      });
    }
    
    // Add metadata information
    dataSourcesData.push({
      dataset: "Model Metadata",
      description: `${metadata?.name || modelName} model information`,
      format: "JSON Object", 
      url: `${baseUrl}/metadata.json`,
      usage: "Model version, description, and technical specifications"
    });
    
    // Create Tabulator table for data sources
    new Tabulator("#dataSourcesTable", {
      data: dataSourcesData,
      layout: "fitColumns",
      width: "100%",
      columns: [
        { title: "Dataset", field: "dataset", width: 180 },
        { title: "Description", field: "description", widthGrow: 2 },
        { title: "Usage in Report", field: "usage", widthGrow: 2 },
        { title: "Format", field: "format", width: 100 },
        { 
          title: "Data Link", 
          field: "url", 
          formatter: function(cell) {
            const url = cell.getValue();
            const filename = url.split('/').pop();
            return `<a href="${url}" target="_blank">${filename}</a>`;
          },
          width: 120
        }
      ]
    });
    
    dataSourcesSection.style.display = 'block';
  } catch (error) {
    console.error('Error loading data sources:', error);
    document.getElementById('dataSourcesInfo').innerHTML = `Data sources and methodology for sector: <strong>${sector?.name || 'Unknown'}</strong><br><em>Error: ${error.message}</em>`;
    document.getElementById('dataSourcesSection').style.display = 'block';
  }
}

// Store table references for updating
var mainTable, matrixTable;

// Keep a global reference to the matrix treemap chart so we can dispose/resize reliably
let matrixTreemapChart = null;
// Keep a reference to the resize handler so we don't add many listeners
let matrixTreemapResizeHandler = null;

// Global variables to store results data (keep full unfiltered data and the shown table data)
let fullTableData = [];
let tableData = [];

function displayTable() {
  const formatType = getCurrentNumberFormat() || "simple";
  
  const columns = [
    { title: "Indicator", field: "indicator", widthGrow: 2 },
    { title: "Direct", field: "direct", formatter: "progress", sorter: "number", headerSortTristate: false, headerSortStartingDir: "desc", minWidth: 160 },
    { title: "Total", field: "total", formatter: "progress", sorter: "number", minWidth: 160 },
    {
      title: "Direct",
      field: formatType === "simple" ? "directValueEasy" : "directValue",
      sorter: formatType === "simple" ? function(a, b, aRow, bRow) {
        return aRow.getData().directValue - bRow.getData().directValue;
      } : "number",
      formatter: function(cell) {
        const val = cell.getValue();
        if (formatType === "simple") {
          return val; // Already formatted by formatCell
        } else if (formatType === "full") {
          return formatCell(val, 'full');
        } else if (formatType === "scientific") {
          let scientificValue = Number(val).toExponential(3);
          let parts = scientificValue.split("e");
          let base = parts[0];
          let exponent = parts[1];
          if (exponent) {
            return `${base}&times;10<sup>${exponent.replace('+', '')}</sup>`;
          }
          return scientificValue;
        }
        return val;
      },
      width: 120
    },
    {
      title: "Total",
      field: formatType === "simple" ? "totalValueEasy" : "totalValue",
      sorter: formatType === "simple" ? function(a, b, aRow, bRow) {
        return aRow.getData().totalValue - bRow.getData().totalValue;
      } : "number",
      formatter: function(cell) {
        const val = cell.getValue();
        if (formatType === "simple") {
          return val; // Already formatted by formatCell
        } else if (formatType === "full") {
          return formatCell(val, 'full');
        } else if (formatType === "scientific") {
          let scientificValue = Number(val).toExponential(3);
          let parts = scientificValue.split("e");
          let base = parts[0];
          let exponent = parts[1];
          if (exponent) {
            return `${base}&times;10<sup>${exponent.replace('+', '')}</sup>`;
          }
          return scientificValue;
        }
        return val;
      },
      width: 120
    },
    { title: "Unit", field: "unit", width: 100 }
  ];

  mainTable = new Tabulator("#table", {
    data: tableData,
    layout: "fitColumns",
    width: "100%",
    columns: columns,
    initialSort: [
      { column: "total", dir: "desc" },
    ]
  });

  // After table is created, render the heatmap based on the table data
}



// Initialize dropdowns and add event listeners
function initializeDropdownsAndEvents() {
  console.log('Initializing dropdowns and events');
  
  // Check if dropdown elements exist
  const localeSelect = document.getElementById('locale-select');
  const numberFormatSelect = document.getElementById('number-format-select');
  console.log('Locale select found:', !!localeSelect);
  console.log('Number format select found:', !!numberFormatSelect);
  
  // Initialize the dropdowns
  if (typeof initializeDropdowns === 'function') {
    initializeDropdowns();
    console.log('Dropdowns initialized');
  } else {
    console.error('initializeDropdowns function not available from config.js');
  }
  
  // Add event listeners to update tables when dropdowns change
  if (localeSelect) {
    localeSelect.addEventListener("change", function() {
      updateTables();
    });
  }
  
  if (numberFormatSelect) {
    numberFormatSelect.addEventListener("change", function() {
      updateTables();
    });
  }

  // Impact filter dropdown (Negative / Positive / All)
  const impactFilterSelect = document.getElementById('impact-filter-select');
  if (impactFilterSelect) {
    impactFilterSelect.addEventListener('change', function() {
      filterTableData();
      updateTables();
    });
  }
}

// Filter fullTableData into tableData according to the impact filter selection
function filterTableData() {
  try {
    const sel = (document.getElementById('impact-filter-select') || {}).value || 'negative';
    if (!fullTableData || fullTableData.length === 0) {
      tableData = [];
      return;
    }

    if (sel === 'all') {
      tableData = fullTableData.slice();
      return;
    }

    // Determine positive vs negative by name heuristics. "Jobs" and "Value Added" are treated as positive impacts.
    const positiveKeywords = [/jobs?/i, /value\s*added/i, /value-added/i, /employment/i, /wage/i, /income/i];

    if (sel === 'positive') {
      tableData = fullTableData.filter(d => {
        const name = (d.indicator || '').toString();
        return positiveKeywords.some(rx => rx.test(name));
      });
    } else {
      // negative: exclude positiveKeywords
      tableData = fullTableData.filter(d => {
        const name = (d.indicator || '').toString();
        return !positiveKeywords.some(rx => rx.test(name));
      });
    }
  } catch (e) {
    console.warn('filterTableData failed', e);
    tableData = fullTableData.slice();
  }
}

// Function to update all tables when format changes
function updateTables() {
  // Recreate the main table with new format (like commodities.html)
  if (tableData && tableData.length > 0) {
    displayTable();
  }
  // For matrix table, just redraw since it uses dynamic formatters
  if (matrixTable) {
    matrixTable.redraw();
  }
}

// Initialize everything when page loads
window.addEventListener('load', function() {
  // Give a small delay to ensure all scripts are loaded
  setTimeout(function() {
    initializeDropdownsAndEvents();
  }, 100);
});

main();
</script>

</body>
</html>